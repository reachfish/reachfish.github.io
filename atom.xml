<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-16T00:35:51.428Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>reachfish</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>phxrpc源码阅读</title>
    <link href="http://yoursite.com/2017/08/11/phxrpc_read/"/>
    <id>http://yoursite.com/2017/08/11/phxrpc_read/</id>
    <published>2017-08-11T01:00:00.000Z</published>
    <updated>2017-08-16T00:35:51.428Z</updated>
    
    <content type="html"><![CDATA[<p>phxrpc是微信开源的rpc框架。</p>
<h1 id="rpc框架"><a href="#rpc框架" class="headerlink" title="rpc框架"></a>rpc框架</h1><h2 id="rpc-http-caller"><a href="#rpc-http-caller" class="headerlink" title="rpc/http_caller"></a>rpc/http_caller</h2><h3 id="HttpCaller"><a href="#HttpCaller" class="headerlink" title="HttpCaller"></a>HttpCaller</h3><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">   BaseTcpStream &amp; socket_;</div><div class="line">   ClientMonitor &amp; client_monitor_;</div><div class="line">   <span class="keyword">int</span> cmdid_;</div><div class="line"></div><div class="line">   HttpRequest request_;</div><div class="line">   HttpResponse response_;</div><div class="line"></div><div class="line"><span class="comment">//连接</span></div><div class="line"><span class="comment">//相当于客户端发起连接</span></div><div class="line"><span class="comment">//request -&gt; post -&gt; rsponse</span></div><div class="line"><span class="keyword">int</span> HttpCaller::Call(<span class="keyword">const</span> google::protobuf::MessageLite &amp; request, google::protobuf::MessageLite * response)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetURI</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * uri, <span class="keyword">int</span> cmdid )</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">SetKeepAlive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> keep_alive )</span></span>;</div></pre></td></tr></table></figure>
<p>说明：http客户端建立连接部分。</p>
<h2 id="rpc-hsha-server"><a href="#rpc-hsha-server" class="headerlink" title="rpc/hsha_server"></a>rpc/hsha_server</h2><h3 id="半同步半异步模式"><a href="#半同步半异步模式" class="headerlink" title="半同步半异步模式"></a>半同步半异步模式</h3><p>一种服务器网络框架模式：使用线程池，这些线程负责执行服务端所有代码的执行。一部分负责IO，一部分负责业务逻辑。两者是独立的，互相不需要管对方做什么，它们是生产者/消费者的关系。</p>
<p>hsha就是网络io部分为非阻塞异步模式，而业务逻辑为同步模式。</p>
<p>同步和异步部分采用一个作业队列(jobQueue)来实现结合。io回调函数中的on_accept, on_recv, on_send, on_close等会把相关任务和上下文放到作业队列，而负责执行作业的线程会被唤醒，取出这些作业并继续执行。</p>
<p>该模式的原文为：<a href="http://www.cs.wustl.edu/~schmidt/PDF/HS-HA.pdf" target="_blank" rel="external">http://www.cs.wustl.edu/~schmidt/PDF/HS-HA.pdf</a> . </p>
<p>开源的spserver就是包含了这种模式。</p>
<h3 id="DataFlow"><a href="#DataFlow" class="headerlink" title="DataFlow"></a>DataFlow</h3><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ThdQueue&lt;<span class="built_in">std</span>::pair&lt;QueueExtData, HttpRequest *&gt; &gt; in_queue_;</div><div class="line">ThdQueue&lt;<span class="built_in">std</span>::pair&lt;QueueExtData, HttpResponse *&gt; &gt; out_queue_;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushRequest</span><span class="params">(<span class="keyword">void</span> * args, HttpRequest * request)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">PluckRequest</span><span class="params">(<span class="keyword">void</span> *&amp; args, HttpRequest *&amp; request)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">PickRequest</span><span class="params">(<span class="keyword">void</span> *&amp; args, HttpRequest *&amp; request)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushResponse</span><span class="params">(<span class="keyword">void</span> * args, HttpResponse * response)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">PluckResponse</span><span class="params">(<span class="keyword">void</span> *&amp; args, HttpResponse *&amp; response)</span></span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanPushRequest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> max_queue_length)</span></span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanPluckResponse</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BreakOut</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h3 id="HshaServerQos"><a href="#HshaServerQos" class="headerlink" title="HshaServerQos"></a>HshaServerQos</h3><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> HshaServerConfig * config_;</div><div class="line">HshaServerStat * hsha_server_stat_;</div><div class="line"><span class="built_in">std</span>::mutex mutex_;</div><div class="line"><span class="built_in">std</span>::condition_variable cv_;</div><div class="line"><span class="built_in">std</span>::thread thread_;</div><div class="line"><span class="keyword">bool</span> break_out_;</div><div class="line"><span class="keyword">int</span> enqueue_reject_rate_; <span class="comment">//入队被拒绝概率</span></div><div class="line"><span class="keyword">int</span> inqueue_avg_wait_time_costs_per_second_cal_last_seq_;  <span class="comment">//这变量名服了</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalFunc</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanAccept</span><span class="params">()</span></span>; <span class="comment">//跟最大连接数相关</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanEnqueue</span><span class="params">()</span></span>; <span class="comment">//满足随机数大于入队被拒绝概率即可</span></div></pre></td></tr></table></figure>
<h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">   WorkerPool * pool_; <span class="comment">//线程池</span></div><div class="line">   <span class="keyword">int</span> uthread_count_; <span class="comment">//协程数</span></div><div class="line">   <span class="keyword">int</span> utherad_stack_size_;</div><div class="line">   <span class="keyword">bool</span> shut_down_;</div><div class="line">   UThreadEpollScheduler * worker_scheduler_;  <span class="comment">//协程模式中的调度器</span></div><div class="line">   <span class="built_in">std</span>::thread thread_;</div><div class="line"></div><div class="line"><span class="comment">//根据协程数是否为0选择线程或协程</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>; </div><div class="line"></div><div class="line"><span class="comment">//data_flow_-&gt;shut_down_</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//线程模式</span></div><div class="line"><span class="comment">//步骤：</span></div><div class="line"><span class="comment">//空闲线程数+1</span></div><div class="line"><span class="comment">//阻塞等待请求 data_flow_-&gt;PluckRequest</span></div><div class="line"><span class="comment">//空闲线程数-1</span></div><div class="line"><span class="comment">//处理业务逻辑WorkerLogic(request)</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ThreadMode</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//协程模式</span></div><div class="line"><span class="comment">//步骤：</span></div><div class="line"><span class="comment">//若当前任务未满，则等待请求 data_flow_-&gt;PickRequest</span></div><div class="line"><span class="comment">//调度器添加执行该任务</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">UThreadMode</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//设置处理request的响应，实际就是交给调度器执行任务</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">HandlerNewRequestFunc</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//协程处理函数，里面就是允许业务逻辑函数 WorkerLogic</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">UThreadFunc</span><span class="params">(<span class="keyword">void</span> * args, HttpRequest * request, <span class="keyword">int</span> queue_wait_time_ms)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//业务处理逻辑 </span></div><div class="line"><span class="comment">//步骤：</span></div><div class="line"><span class="comment">//线程池的处理函数来处理得到的请求 pool-&gt;dispatch_ </span></div><div class="line"><span class="comment">//把结果返回给data_flow_中 data_flow_-&gt;PushResponse</span></div><div class="line"><span class="comment">//线程池通知epoll</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">WorkerLogic</span><span class="params">(<span class="keyword">void</span> * args, HttpRequest * request, <span class="keyword">int</span> queue_wait_time_ms)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//线程池通知epoll</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h3 id="WorkerPool"><a href="#WorkerPool" class="headerlink" title="WorkerPool"></a>WorkerPool</h3><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>;</span></div><div class="line">UThreadEpollScheduler * scheduler_;</div><div class="line">DataFlow * data_flow_;</div><div class="line">HshaServerStat * hsha_server_stat_;</div><div class="line">Dispatch_t dispatch_;</div><div class="line"><span class="keyword">void</span> * args_;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Worker *&gt; worker_list_;</div><div class="line"><span class="keyword">size_t</span> last_notify_idx_;</div><div class="line"><span class="built_in">std</span>::mutex mutex_;</div></pre></td></tr></table></figure>
<h3 id="HshaServerIO"><a href="#HshaServerIO" class="headerlink" title="HshaServerIO"></a>HshaServerIO</h3><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">int</span> idx_;</div><div class="line">   UThreadEpollScheduler * scheduler_;</div><div class="line">   <span class="keyword">const</span> HshaServerConfig * config_;</div><div class="line">   DataFlow * data_flow_;</div><div class="line">   <span class="keyword">int</span> listen_fd_;</div><div class="line">   HshaServerStat * hsha_server_stat_;</div><div class="line">   HshaServerQos * hsha_server_qos_;</div><div class="line">   WorkerPool * worker_pool_;</div><div class="line"></div><div class="line">   <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; accepted_fd_list_; <span class="comment">//accept fd </span></div><div class="line">   <span class="built_in">std</span>::mutex queue_mutex_;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">RunForever</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//fd入队列，并且进行通告NotifyEpoll</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">AddAcceptedFd</span><span class="params">(<span class="keyword">int</span> accepted_fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//调度器将accept队列里的fd进行添加任务 scheduler_-&gt;AddTask，处理的入口函数是 IOFunc</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">HandlerAcceptedFd</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//while(1)&#123;</span></div><div class="line"><span class="comment">//	 从accept_fd中接收request，并且把request push到data_flow_中</span></div><div class="line"><span class="comment">//   协程挂起等待调度器执行完毕，返回response，并且把response返回去</span></div><div class="line"><span class="comment">//   如果出错或者不是keep alive的，则停止循环</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">IOFunc</span><span class="params">(<span class="keyword">int</span> accept_fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//把data_flow_中的response给返回去</span></div><div class="line">   <span class="function">UThreadSocket_t * <span class="title">ActiveSocketFunc</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h3 id="HshaServerUnit"><a href="#HshaServerUnit" class="headerlink" title="HshaServerUnit"></a>HshaServerUnit</h3><p>单个服务器</p>
<p>代码 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   HshaServer * hsha_server_;</div><div class="line">   UThreadEpollScheduler scheduler_;</div><div class="line">   DataFlow data_flow_;</div><div class="line">   WorkerPool worker_pool_;</div><div class="line">   HshaServerIO hsha_server_io_;</div><div class="line">   <span class="built_in">std</span>::thread thread_;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//hsha_server_io_.RunForever</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">RunFunc</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//hsha_server_io_.AddAcceptedFd</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">AddAcceptedFd</span><span class="params">(<span class="keyword">int</span> accepted_fd)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="HshaServerAcceptor"><a href="#HshaServerAcceptor" class="headerlink" title="HshaServerAcceptor"></a>HshaServerAcceptor</h3><p>代码 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   HshaServer * hsha_server_;</div><div class="line">   <span class="keyword">size_t</span> idx_;</div><div class="line"></div><div class="line"><span class="comment">//专门listen连接，连接accept后，就抛给io线程侦听</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">LoopAccept</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * bind_ip, <span class="keyword">const</span> <span class="keyword">int</span> port)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="HshaServer"><a href="#HshaServer" class="headerlink" title="HshaServer"></a>HshaServer</h3><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">const</span> HshaServerConfig * config_;</div><div class="line">   ServerMonitorPtr hsha_server_monitor_;</div><div class="line">   HshaServerStat hsha_server_stat_;</div><div class="line">   HshaServerQos hsha_server_qos_;</div><div class="line">   HshaServerAcceptor hsha_server_acceptor_;</div><div class="line"></div><div class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;HshaServerUnit *&gt; server_unit_list_;</div><div class="line"></div><div class="line"><span class="comment">//while(1) &#123;</span></div><div class="line"><span class="comment">// acceptor 一直保持listen</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">RunForever</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HshaServer包含:</p>
<ul>
<li><p>多个执行单元HshaServerUnit， 每个执行单元中包含一个data_flow，一个io处理和一个业务逻辑处理池 WorkerPool，一个io可以处理多个accept fd。 </p>
</li>
<li><p>一个acceptor，专门用于listen收发上来的accept fd，当建立以一个连接连接后，按Round Robin算法分配到一个执行单元 HshaServerUnit 上。 HshaServer的主函数就是一直运行acceptor的Loop Listen逻辑。</p>
</li>
<li><p>质量保证 HshaServerQos。</p>
</li>
<li><p>统计工具 HshaServerStat。</p>
</li>
</ul>
<h2 id="rpc-thread-queue"><a href="#rpc-thread-queue" class="headerlink" title="rpc/thread_queue"></a>rpc/thread_queue</h2><h3 id="ThdQueue"><a href="#ThdQueue" class="headerlink" title="ThdQueue"></a>ThdQueue</h3><p>多线程环境下的加锁队列</p>
<p>代码 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//压入队列</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp; value)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//出队列，如果队列为空，则阻塞等待</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">pluck</span><span class="params">(T &amp; value)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//出队列，如果为空，则返回false</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">pick</span><span class="params">(T &amp; value)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//关闭 </span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">break_out</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h1 id="network框架"><a href="#network框架" class="headerlink" title="network框架"></a>network框架</h1><h2 id="协程实现"><a href="#协程实现" class="headerlink" title="协程实现"></a>协程实现</h2><p>数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> &#123;</span>  </div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span>   <span class="comment">//当前上下文终止时，将会恢复的上下文</span></div><div class="line">	<span class="keyword">sigset_t</span>         uc_sigmask; <span class="comment">//该上下文中阻塞信号的信号 </span></div><div class="line">	<span class="keyword">stack_t</span>          uc_stack;   <span class="comment">//该上下文使用的栈 </span></div><div class="line">	<span class="keyword">mcontext_t</span>       uc_mcontext; <span class="comment">//特定的机器表示，包括线程使用的特定寄存器 </span></div><div class="line">	...  </div><div class="line">&#125; <span class="keyword">ucontext_t</span>;</div></pre></td></tr></table></figure>
<h3 id="int-getcontext-ucontext-t-ucp"><a href="#int-getcontext-ucontext-t-ucp" class="headerlink" title="int getcontext(ucontext_t *ucp);"></a>int getcontext(ucontext_t *ucp);</h3><p>将当前上下文保存到 ucp 中。</p>
<h3 id="int-setcontext-const-ucontext-t-ucp"><a href="#int-setcontext-const-ucontext-t-ucp" class="headerlink" title="int setcontext(const ucontext_t *ucp);"></a>int setcontext(const ucontext_t *ucp);</h3><p>切换到ucp表示的上下文中</p>
<ol>
<li>如果ucp是getcontext取得的，则会继续继续这个调用</li>
<li>如果ucp是是通过调用makecontext取得,程序会调用makecontext函数的第二个参数指向的函数，如果func函数返回,则恢复makecontext第一个参数指向的上下文第一个参数指向的上下文context_t中指向的uc_link. 如果uc_link为NULL,则线程退出。</li>
</ol>
<h3 id="void-makecontext-ucontext-t-ucp-void-func-int-argc-…"><a href="#void-makecontext-ucontext-t-ucp-void-func-int-argc-…" class="headerlink" title="void makecontext(ucontext_t ucp, void (func)(), int argc, …);"></a>void makecontext(ucontext_t <em>ucp, void (</em>func)(), int argc, …);</h3><p>makecontext修改通过getcontext取得的上下文ucp(这意味着调用makecontext前必须先调用getcontext)。然后给该上下文指定一个栈空间ucp-&gt;stack，设置后继的上下文ucp-&gt;uc_link.</p>
<p>当上下文通过setcontext或者swapcontext激活后，执行func函数，argc为func的参数个数，后面是func的参数序列。当func执行返回后，继承的上下文被激活，如果继承上下文为NULL时，线程退出。</p>
<h3 id="int-swapcontext-ucontext-t-oucp-ucontext-t-ucp"><a href="#int-swapcontext-ucontext-t-oucp-ucontext-t-ucp" class="headerlink" title="int swapcontext(ucontext_t oucp, ucontext_t ucp);"></a>int swapcontext(ucontext_t <em>oucp, ucontext_t </em>ucp);</h3><p>保存当前上下文到oucp结构体中，然后激活upc上下文。 </p>
<h2 id="利用-ucontext-实现的一个简单协程"><a href="#利用-ucontext-实现的一个简单协程" class="headerlink" title="利用 ucontext 实现的一个简单协程"></a>利用 ucontext 实现的一个简单协程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">scheduler&#123;</div><div class="line">	<span class="keyword">ucontext_t</span> main;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">co_t</span>&gt; vco;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//创建一个co结构，设置其栈，其后继协程uc_link，设置其入口函数makecontext</span></div><div class="line">co_create(scheduler, func, arg)</div><div class="line"></div><div class="line"><span class="comment">//swapcontext(&amp;main, co)</span></div><div class="line">co_resume(co)</div><div class="line"></div><div class="line"><span class="comment">//swapcontext(co, &amp;main)</span></div><div class="line">co_yield(co)</div></pre></td></tr></table></figure>
<h2 id="network-uthread-context-base"><a href="#network-uthread-context-base" class="headerlink" title="network/uthread_context_base"></a>network/uthread_context_base</h2><h3 id="UThreadContext"><a href="#UThreadContext" class="headerlink" title="UThreadContext"></a>UThreadContext</h3><p>协程context</p>
<p>代码 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">static</span> ContextCreateFunc_t context_create_func_;</div><div class="line"></div><div class="line"><span class="comment">//使用工厂模式</span></div><div class="line"><span class="comment">//使用函数 context_create_func_ 来创建context</span></div><div class="line">   <span class="function"><span class="keyword">static</span> UThreadContext * <span class="title">Create</span><span class="params">(<span class="keyword">size_t</span> stack_size, </span></span></div><div class="line">           UThreadFunc_t func, <span class="keyword">void</span> * args, </div><div class="line">           UThreadDoneCallback_t callback, <span class="keyword">const</span> <span class="keyword">bool</span> need_stack_protect);</div><div class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetContextCreateFunc</span><span class="params">(ContextCreateFunc_t context_create_func)</span></span>;</div><div class="line">   <span class="function"><span class="keyword">static</span> ContextCreateFunc_t <span class="title">GetContextCreateFunc</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Make</span><span class="params">(UThreadFunc_t func, <span class="keyword">void</span> * args)</span> </span>= <span class="number">0</span>;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Resume</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Yield</span><span class="params">()</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure>
<h2 id="network-uthread-context-system"><a href="#network-uthread-context-system" class="headerlink" title="network/uthread_context_system"></a>network/uthread_context_system</h2><h3 id="UThreadContextSystem"><a href="#UThreadContextSystem" class="headerlink" title="UThreadContextSystem"></a>UThreadContextSystem</h3><p>从UThreadContext中继承</p>
<p>代码 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">ucontext_t</span> context_;</div><div class="line">   UThreadFunc_t func_;</div><div class="line">   <span class="keyword">void</span> * args_;</div><div class="line">   UThreadStackMemory stack_;   <span class="comment">//自己维护一个栈</span></div><div class="line">   UThreadDoneCallback_t callback_;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//工厂模式</span></div><div class="line"><span class="comment">//生成一个实例</span></div><div class="line">   <span class="function"><span class="keyword">static</span> UThreadContext * <span class="title">DoCreate</span><span class="params">(<span class="keyword">size_t</span> stack_size, </span></span></div><div class="line">           UThreadFunc_t func, <span class="keyword">void</span> * args, UThreadDoneCallback_t callback,</div><div class="line">           <span class="keyword">const</span> <span class="keyword">bool</span> need_stack_protect);</div><div class="line"></div><div class="line"><span class="comment">//makecontext -&gt; (func -&gt; UThreadFuncWrapper)</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Make</span><span class="params">(UThreadFunc_t func, <span class="keyword">void</span> * args)</span> override</span>;</div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">Resume</span><span class="params">()</span> override</span>;  <span class="comment">//swapcontext(main, context)</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">Yield</span><span class="params">()</span> override</span>;   <span class="comment">//swapcontext(context, main)</span></div><div class="line"></div><div class="line">   <span class="keyword">ucontext_t</span> * GetMainContext();   <span class="comment">//使用静态变量保存一个 main context</span></div><div class="line"></div><div class="line"><span class="comment">//wrap用户自定义的函数，</span></div><div class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UThreadFuncWrapper</span><span class="params">(<span class="keyword">uint32_t</span> low32, <span class="keyword">uint32_t</span> high32)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="network-uthread-epoll"><a href="#network-uthread-epoll" class="headerlink" title="network/uthread_epoll"></a>network/uthread_epoll</h2><h3 id="EpollNotifier"><a href="#EpollNotifier" class="headerlink" title="EpollNotifier"></a>EpollNotifier</h3><p>结构 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">   UThreadEpollScheduler * scheduler_;</div><div class="line">   <span class="keyword">int</span> pipe_fds_[<span class="number">2</span>];  <span class="comment">//用于通知scheduler，通知时往[1]写"a"，scheduler_侦听[0]，将会触发读事件</span></div><div class="line"></div><div class="line"><span class="comment">//scheduler_-&gt;AddTask( this-&gt;Fun )</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//while(true)&#123;</span></div><div class="line"><span class="comment">//  UThreadPoll</span></div><div class="line"><span class="comment">//&#125; </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//想管道中写a，触发读通知</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h3 id="UThreadEpollScheduler"><a href="#UThreadEpollScheduler" class="headerlink" title="UThreadEpollScheduler"></a>UThreadEpollScheduler</h3><p>结构 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">   UThreadRuntime runtime_;</div><div class="line">   <span class="keyword">int</span> max_task_;  <span class="comment">//最大任务个数</span></div><div class="line">   TaskQueue todo_list_;</div><div class="line">   <span class="keyword">int</span> epoll_fd_;   <span class="comment">//epoll_create返回的结构</span></div><div class="line"></div><div class="line">   Timer timer_;</div><div class="line">   <span class="keyword">bool</span> closed_;</div><div class="line">   <span class="keyword">bool</span> run_forever_;</div><div class="line"></div><div class="line">   UThreadActiveSocket_t active_socket_func_;</div><div class="line">   UThreadHandlerAcceptedFdFunc_t handler_accepted_fd_func_;</div><div class="line">   UThreadHandlerNewRequest_t handler_new_request_func_;</div><div class="line"></div><div class="line">   <span class="keyword">int</span> epoll_wait_events_; <span class="comment">//在统计1s过程中保存的事件个数</span></div><div class="line">   <span class="keyword">int</span> epoll_wait_events_per_second_; <span class="comment">//每秒处理的事件个数</span></div><div class="line">   <span class="keyword">uint64_t</span> epoll_wait_events_last_cal_time_; <span class="comment">//更新每秒事件个数的时间</span></div><div class="line"></div><div class="line">   EpollNotifier epoll_wake_up_;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//获取static的静态单例</span></div><div class="line">   <span class="function"><span class="keyword">static</span> UThreadEpollScheduler * <span class="title">Instance</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//runtime_未完成的任务 + todo_list_ 的个数少于 max_task_</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">IsTaskFull</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//放到todo_list_中</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">AddTask</span><span class="params">(UThreadFunc_t func, <span class="keyword">void</span> * args)</span></span>;</div><div class="line"></div><div class="line">   <span class="function">UThreadSocket_t * <span class="title">CreateSocket</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> socket_timeout_ms = <span class="number">5000</span>, </span></span></div><div class="line">           <span class="keyword">int</span> connect_timeout_ms = <span class="number">200</span>, <span class="keyword">bool</span> no_delay = <span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//active_socket_func_</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">SetActiveSocketFunc</span><span class="params">(UThreadActiveSocket_t active_socket_func)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//handler_accepted_fd_func_</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">SetHandlerAcceptedFdFunc</span><span class="params">(UThreadHandlerAcceptedFdFunc_t handler_accepted_fd_func)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//handler_new_request_func_</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">SetHandlerNewRequestFunc</span><span class="params">(UThreadHandlerNewRequest_t handler_new_request_func)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//runtime_.yield()</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">YieldTask</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//ConsumeTodoList</span></div><div class="line"><span class="comment">//while(run_forever_ || runtime_ 的任务未处理完之前)&#123;</span></div><div class="line"><span class="comment">// epoll_wait</span></div><div class="line"><span class="comment">// runtime_ 恢复协程</span></div><div class="line"><span class="comment">// 继续ConsumeTodoList</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">Run</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//执行自己的Run 和 NotifyEpoll 的Run</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">RunForever</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span>;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">NotifyEpoll</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//runtime_.GetCurrUThread()</span></div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">GetCurrUThread</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//给该socket添加超时</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">AddTimer</span><span class="params">(UThreadSocket_t * socket, <span class="keyword">int</span> timeout_ms)</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">RemoveTimer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> timer_id)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//runtime_恢复timeout的协程</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">DealwithTimeout</span><span class="params">(<span class="keyword">int</span> &amp; next_timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//runtime_ 创建、resume todo_list_ 中所有的任务</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ConsumeTodoList</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//runtime_ resume socketlist 中所有的任务</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ResumeAll</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//统计每秒的事件个数</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">StatEpollwaitEvents</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> event_count)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="int-UThreadPoll-UThreadSocket-t-amp-socket-int-events-int-revents-int-timeout-ms"><a href="#int-UThreadPoll-UThreadSocket-t-amp-socket-int-events-int-revents-int-timeout-ms" class="headerlink" title="int UThreadPoll(UThreadSocket_t &amp; socket, int events, int * revents, int timeout_ms)"></a>int UThreadPoll(UThreadSocket_t &amp; socket, int events, int * revents, int timeout_ms)</h3><p>socket对应的协程添加event事件和timeout超时，接着协程被挂起。</p>
<h3 id="int-UThreadPoll-UThreadSocket-t-list-int-count-int-timeout-ms"><a href="#int-UThreadPoll-UThreadSocket-t-list-int-count-int-timeout-ms" class="headerlink" title="int UThreadPoll(UThreadSocket_t * list[], int count, int timeout_ms)"></a>int UThreadPoll(UThreadSocket_t * list[], int count, int timeout_ms)</h3><p>socketlist对应的协程添加event和timeout事件，接着协程被挂起</p>
<h3 id="int-UThreadConnect-UThreadSocket-t-amp-socket-const-struct-sockaddr-addr-socklen-t-addrlen"><a href="#int-UThreadConnect-UThreadSocket-t-amp-socket-const-struct-sockaddr-addr-socklen-t-addrlen" class="headerlink" title="int UThreadConnect(UThreadSocket_t &amp; socket, const struct sockaddr *addr, socklen_t addrlen)"></a>int UThreadConnect(UThreadSocket_t &amp; socket, const struct sockaddr *addr, socklen_t addrlen)</h3><p>socket建立连接</p>
<h3 id="int-UThreadAccept-UThreadSocket-t-amp-socket-struct-sockaddr-addr-socklen-t-addrlen"><a href="#int-UThreadAccept-UThreadSocket-t-amp-socket-struct-sockaddr-addr-socklen-t-addrlen" class="headerlink" title="int UThreadAccept(UThreadSocket_t &amp; socket, struct sockaddr addr, socklen_t addrlen)"></a>int UThreadAccept(UThreadSocket_t &amp; socket, struct sockaddr <em>addr, socklen_t </em>addrlen)</h3><p>socket accept</p>
<h2 id="network-uthread-runtime"><a href="#network-uthread-runtime" class="headerlink" title="network/uthread_runtime"></a>network/uthread_runtime</h2><h3 id="UThreadRuntime"><a href="#UThreadRuntime" class="headerlink" title="UThreadRuntime"></a>UThreadRuntime</h3><p>结构体中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ContextSlot</span> &#123;</span></div><div class="line">       ContextSlot() &#123;</div><div class="line">           context = <span class="literal">nullptr</span>;</div><div class="line">           next_done_item = <span class="number">-1</span>;</div><div class="line">       &#125;</div><div class="line">       UThreadContext * context;</div><div class="line">       <span class="keyword">int</span> next_done_item;  <span class="comment">//已完成任务通过这个字段构成一个已完成任务协程链（空闲协程链）</span></div><div class="line">       <span class="keyword">int</span> status; <span class="comment">//创建时为 UTHREAD_SUSPEND，完成任务时为UTHREAD_DONE, resume协程时为UTHREAD_RUNNING</span></div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   <span class="keyword">size_t</span> stack_size_;</div><div class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ContextSlot&gt; context_list_;   <span class="comment">//协程数组中的上下文会重复使用</span></div><div class="line">   <span class="keyword">int</span> first_done_item_;  <span class="comment">//空闲协程，通过 next_done_item 来组成一个空闲协程链</span></div><div class="line">   <span class="keyword">int</span> current_uthread_;  <span class="comment">//当前运行的协程下标</span></div><div class="line">   <span class="keyword">int</span> unfinished_item_count_;</div><div class="line">   <span class="keyword">bool</span> need_stack_protect_;</div><div class="line"></div><div class="line"><span class="comment">//如果context_list_有已经完成任务的协程，则把任务分给它，否则创建新的协程，并加入到context_list_中</span></div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">Create</span><span class="params">(UThreadFunc_t func, <span class="keyword">void</span> * args)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//current_uthread_</span></div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">GetCurrUThread</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">Yield</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">Resume</span><span class="params">(<span class="keyword">size_t</span> index)</span></span>;  <span class="comment">//恢复协程</span></div><div class="line"></div><div class="line"><span class="comment">//判断 unfinished_item_count_ 是否为0</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">IsAllDone</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">GetUnfinishedItemCount</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//协程完成的回调，主要是协程标记为空闲，并且未完成任务数-1</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">UThreadDoneCallback</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h2 id="network-timer"><a href="#network-timer" class="headerlink" title="network/timer"></a>network/timer</h2><p>超时任务，使用堆来维护</p>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><h2 id="http-http-proto"><a href="#http-http-proto" class="headerlink" title="http/http_proto"></a>http/http_proto</h2><h3 id="HttpProto"><a href="#HttpProto" class="headerlink" title="HttpProto"></a>HttpProto</h3><p>http request/response 解析。 类似libevent中http的解析，包括解析头部、body等。</p>
<h2 id="http-http-msg"><a href="#http-http-msg" class="headerlink" title="http/http_msg"></a>http/http_msg</h2><p>http消息，基类是HttpMessage，派生出HttpRequest和HttpResponse。</p>
<h2 id="http-http-dispatcher"><a href="#http-http-dispatcher" class="headerlink" title="http/http_dispatcher"></a>http/http_dispatcher</h2><p>貌似没调用到的地方。</p>
<h2 id="http-http-client"><a href="#http-http-client" class="headerlink" title="http/http_client"></a>http/http_client</h2><p>HttpClient实现GET和POST方法。调用HttpProto中的SendReq，然后对Response再调用HttpProto进行解析。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;phxrpc是微信开源的rpc框架。&lt;/p&gt;
&lt;h1 id=&quot;rpc框架&quot;&gt;&lt;a href=&quot;#rpc框架&quot; class=&quot;headerlink&quot; title=&quot;rpc框架&quot;&gt;&lt;/a&gt;rpc框架&lt;/h1&gt;&lt;h2 id=&quot;rpc-http-caller&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>libco的阅读</title>
    <link href="http://yoursite.com/2017/08/09/libco_read/"/>
    <id>http://yoursite.com/2017/08/09/libco_read/</id>
    <published>2017-08-09T01:00:00.000Z</published>
    <updated>2017-08-11T03:12:10.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stStackMem_t</span>&#123;</span></div><div class="line">	stCoRoutine_t* occupy_co; <span class="comment">//标明该栈当前被谁占有，共享栈时才可能会被占用</span></div><div class="line">	<span class="keyword">int</span> stack_size;</div><div class="line">	<span class="keyword">char</span>* stack_bp; <span class="comment">//stack_buffer + stack_size</span></div><div class="line">	<span class="keyword">char</span>* stack_buffer;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//共享栈是把stack_array挨个进行分配</span></div><div class="line"><span class="comment">//共享栈使用Round Robin算法进行分配，当两个协程使用同一块内存时，轮到谁执行时谁就会抢占</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stShareStack_t</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_idx;</div><div class="line">	<span class="keyword">int</span> stack_size;</div><div class="line">	<span class="keyword">int</span> count;</div><div class="line">	stStackMem_t** stack_array;  <span class="comment">//count个stack_size的stStackMem_t</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stCoRoutineAttr_t</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> stack_size; <span class="comment">//128*1024 ~ 8*1024*1024，且是0x1000的倍数</span></div><div class="line">	stShareStack_t*  share_stack; <span class="comment">//是否使用共享栈</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stCoRoutine_t</span></span></div><div class="line">&#123;</div><div class="line">	stCoRoutineEnv_t *env;</div><div class="line">	<span class="keyword">pfn_co_routine_t</span> pfn;</div><div class="line">	<span class="keyword">void</span> *arg;</div><div class="line">	<span class="keyword">coctx_t</span> ctx; <span class="comment">//里面的指针指向stack_mem</span></div><div class="line"></div><div class="line">	<span class="keyword">char</span> cStart;</div><div class="line">	<span class="keyword">char</span> cEnd;</div><div class="line">	<span class="keyword">char</span> cIsMain;</div><div class="line">	<span class="keyword">char</span> cEnableSysHook;</div><div class="line">	<span class="keyword">char</span> cIsShareStack;</div><div class="line"></div><div class="line">	<span class="keyword">void</span> *pvEnv;</div><div class="line"></div><div class="line">	<span class="comment">//char sRunStack[ 1024 * 128 ];</span></div><div class="line">	stStackMem_t* stack_mem;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">//save satck buffer while confilct on same stack_buffer;</span></div><div class="line">	<span class="keyword">char</span>* stack_sp; </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> save_size;</div><div class="line">	<span class="keyword">char</span>* save_buffer;</div><div class="line"></div><div class="line">	stCoSpec_t aSpec[<span class="number">1024</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//每个线程对应一个协程栈</span></div><div class="line"><span class="comment">//创建一个线程的co env时，需要先创建一个入口协程、pEpoll数据结构。</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stCoRoutineEnv_t</span></span></div><div class="line">&#123;</div><div class="line">	stCoRoutine_t *pCallStack[<span class="number">128</span>]; <span class="comment">//每个线程的嵌套协程最大深度128</span></div><div class="line">	<span class="keyword">int</span> iCallStackSize;</div><div class="line">	stCoEpoll_t *pEpoll;  <span class="comment">//该线程中关联协程的epoll结构，遇到send,recv等时会自动切换协程，pEpoll就是检测里面遇到的各个fd事件</span></div><div class="line">	<span class="comment">//struct stCoEpoll_t</span></div><div class="line">	<span class="comment">//&#123;</span></div><div class="line">	<span class="comment">//	int iEpollFd;				   //epoll_create返回的套接字</span></div><div class="line">	<span class="comment">//	static const int _EPOLL_SIZE = 1024 * 10;</span></div><div class="line">	<span class="comment">//	struct stTimeout_t *pTimeout;   //维护60s长度的队列</span></div><div class="line">	<span class="comment">//	struct stTimeoutItemLink_t *pstTimeoutList;</span></div><div class="line">	<span class="comment">//	struct stTimeoutItemLink_t *pstActiveList;</span></div><div class="line">	<span class="comment">//	co_epoll_res *result; </span></div><div class="line">	<span class="comment">//&#125;;</span></div><div class="line"></div><div class="line">	<span class="comment">//for copy stack log lastco and nextco</span></div><div class="line">	stCoRoutine_t* pending_co; <span class="comment">//即将切换的协程</span></div><div class="line">	stCoRoutine_t* occupy_co;  <span class="comment">//标明谁的栈被pending_co给抢占了</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">g_arrCoEnvPerThread;  <span class="comment">//所有线程对应的co env数组</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stTimeoutItem_t</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="keyword">enum</span></div><div class="line">	&#123;</div><div class="line">		eMaxTimeout = <span class="number">40</span> * <span class="number">1000</span> <span class="comment">//40s</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">//以下三项是链表结构</span></div><div class="line">	stTimeoutItem_t *pPrev;</div><div class="line">	stTimeoutItem_t *pNext;</div><div class="line">	stTimeoutItemLink_t *pLink; <span class="comment">//所指向的链表，结构如下：</span></div><div class="line">	<span class="comment">//struct stTimeoutItemLink_t</span></div><div class="line">	<span class="comment">//&#123;</span></div><div class="line">	<span class="comment">//	stTimeoutItem_t *head;</span></div><div class="line">	<span class="comment">//	stTimeoutItem_t *tail;</span></div><div class="line">	<span class="comment">//&#125;;</span></div><div class="line"></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ullExpireTime;</div><div class="line"></div><div class="line">	OnPreparePfn_t pfnPrepare;  <span class="comment">//从原队列中删除，并将其加入active队列中</span></div><div class="line">	OnProcessPfn_t pfnProcess;  <span class="comment">//事件回调函数，实际调用时是恢复协程的执行co_resume(pArg)</span></div><div class="line"></div><div class="line">	<span class="keyword">void</span> *pArg; <span class="comment">// routine </span></div><div class="line">	<span class="keyword">bool</span> bTimeout; <span class="comment">//表明是否是Timeout了</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stTimeout_t</span></span></div><div class="line">&#123;</div><div class="line">	stTimeoutItemLink_t *pItems; <span class="comment">//pItems[i]表示一个链表链表，里面的元素的超时时间-ullStart=i</span></div><div class="line">	<span class="keyword">int</span> iItemSize;</div><div class="line"></div><div class="line">	<span class="comment">//设上次timeout的时间为t1, 结束index为 idx1</span></div><div class="line">	<span class="comment">//那么当经过时间t后，处理的范围为[idx1, idx1 + t]</span></div><div class="line">	<span class="comment">//然后更新idx2 = idx1 + t, t2 = t1 + t</span></div><div class="line">	<span class="comment">//也是一个圈循环处理</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ullStart;  </div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> llStartIdx;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stPollItem_t</span> :</span> stTimeoutItem_t </div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">pSelf</span>;</span></div><div class="line">	stPoll_t *pPoll;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">stEvent</span>;</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stPoll_t</span> :</span> stTimeoutItem_t </div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">fds</span>;</span></div><div class="line">	<span class="keyword">nfds_t</span> nfds; <span class="comment">// typedef unsigned long int nfds_t;</span></div><div class="line"></div><div class="line">	stPollItem_t *pPollItems;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> iAllEventDetach;</div><div class="line">	<span class="keyword">int</span> iEpollFd;</div><div class="line">	<span class="keyword">int</span> iRaiseCnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coctx_param_t</span>&#123;</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *s1;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *s2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coctx_t</span>&#123;</span></div><div class="line">	<span class="keyword">void</span> *regs[<span class="number">14</span>];</div><div class="line">	<span class="keyword">size_t</span> ss_size;</div><div class="line">	<span class="keyword">char</span> *ss_sp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="co-swap-curr-pending-co"><a href="#co-swap-curr-pending-co" class="headerlink" title="co_swap(curr, pending_co)"></a>co_swap(curr, pending_co)</h3><p>协程切换</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p>获取当前线程的env，设置其pending_co(抢占别的栈的协程)和occupy_co(栈被抢的协程)。如果传入参数pending_co为共享栈的，则它们都为空，否则:<br>更新env-&gt;pending_co和env-&gt;occupy_co。并且把occupy_co的栈给保存起来(把sp到bp之间的数据拷贝到save_buffer中)。</p>
</li>
<li><p>进行上下文切换coctx_swap，切换之后可能会换了上下文</p>
</li>
<li><p>重新获取cur_env和它的pending_co,occupy_co，如果这两者不同并且pending_co的save_buffer不为空，则把save_buffer中的内容重新拷到它的栈中去。</p>
</li>
</ol>
<h3 id="co-alloc-stackmem-stack-size"><a href="#co-alloc-stackmem-stack-size" class="headerlink" title="co_alloc_stackmem(stack_size)"></a>co_alloc_stackmem(stack_size)</h3><p>分配一个copy栈。</p>
<h3 id="co-alloc-sharestack-count-stack-size"><a href="#co-alloc-sharestack-count-stack-size" class="headerlink" title="co_alloc_sharestack(count, stack_size)"></a>co_alloc_sharestack(count, stack_size)</h3><p>分配共享栈，包含了count个栈，每个栈的大小为stack_size。</p>
<h3 id="co-eventloop-stCoEpoll-t-ctx-pfn-arg"><a href="#co-eventloop-stCoEpoll-t-ctx-pfn-arg" class="headerlink" title="co_eventloop(stCoEpoll_t* ctx, pfn, arg)"></a>co_eventloop(stCoEpoll_t* ctx, pfn, arg)</h3><p>操作为：</p>
<p>while(true){<br>    事件终端 + 1ms 超时检测，内部调用co_poll_wait。<br>}</p>
<p>对线程所属的CoEpoll进行loop循环，当协程超时或者触发事件时，则会恢复协程。循环会一直执行，直到pfn(arg)返回-1才跳出循环。</p>
<h3 id="co-poll-inner-stCoEpoll-t-ctx-struct-pollfd-fds-nfds-t-nfds-int-timeout-poll-pfn-t-pollfunc"><a href="#co-poll-inner-stCoEpoll-t-ctx-struct-pollfd-fds-nfds-t-nfds-int-timeout-poll-pfn-t-pollfunc" class="headerlink" title="co_poll_inner(stCoEpoll_t* ctx, struct pollfd fds[], nfds_t nfds, int timeout, poll_pfn_t pollfunc)"></a>co_poll_inner(stCoEpoll_t* ctx, struct pollfd fds[], nfds_t nfds, int timeout, poll_pfn_t pollfunc)</h3><p>当前协程添加epoll事件，添加timeout，添加完成后当前线程进行协程切换。</p>
<h3 id="co-resume-co"><a href="#co-resume-co" class="headerlink" title="co_resume(co)"></a>co_resume(co)</h3><p>恢复协程的执行。<br>将当前协程压入栈顶，将栈顶下一个协程切换到当前的协程。</p>
<p>何时调用：</p>
<ol>
<li>OnPollProcessEvent: 遇到epoll事件时。</li>
<li>OnSignalProcessEvent</li>
<li>OnCoroutineEvent: 代码中没碰到这种情况。</li>
</ol>
<h3 id="CoRoutineFunc-co"><a href="#CoRoutineFunc-co" class="headerlink" title="CoRoutineFunc(co, *)"></a>CoRoutineFunc(co, *)</h3><p>所有协程的入口调用函数。</p>
<p><strong>步骤：</strong></p>
<p>执行co-&gt;pfn(co-&gt;arg)函数。<br>co-&gt;env切换协程co_yield_env(栈顶协程退出，并且切换到栈顶的下一个协程)。</p>
<h3 id="AddTimeout-apTimeout-apItem-allNow"><a href="#AddTimeout-apTimeout-apItem-allNow" class="headerlink" title="AddTimeout(apTimeout, apItem, allNow)"></a>AddTimeout(apTimeout, apItem, allNow)</h3><p>将apItem加入到apTimeout中。</p>
<p>满足的条件为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">timeoutList.ullStart &lt; allNow &lt; apItem.ullExpireTime</div></pre></td></tr></table></figure>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步唤醒就是把协程添加到 pstActiveList 中，然后在其响应函数 OnSignalProcessEvent 中恢复协程。</p>
<h3 id="int-co-cond-signal-stCoCond-t-si"><a href="#int-co-cond-signal-stCoCond-t-si" class="headerlink" title="int co_cond_signal( stCoCond_t *si )"></a>int co_cond_signal( stCoCond_t *si )</h3><p>唤醒Cond List的头部。</p>
<h3 id="int-co-cond-broadcast-stCoCond-t-si"><a href="#int-co-cond-broadcast-stCoCond-t-si" class="headerlink" title="int co_cond_broadcast( stCoCond_t *si )"></a>int co_cond_broadcast( stCoCond_t *si )</h3><p>唤醒Cond List中的所有元素。</p>
<h3 id="int-co-cond-timedwait-stCoCond-t-link-int-ms"><a href="#int-co-cond-timedwait-stCoCond-t-link-int-ms" class="headerlink" title="int co_cond_timedwait( stCoCond_t *link,int ms )"></a>int co_cond_timedwait( stCoCond_t *link,int ms )</h3><p>等待条件满足。<br>如果超时，则添加超时事件，添加完毕之后，进行协程切换，等待其他条件满足时，再唤醒。</p>
<h3 id="example-cond"><a href="#example-cond" class="headerlink" title="example_cond"></a>example_cond</h3><p>协程间的同步，改例子是生产者和消费者之间的协作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Producer</span><span class="params">(<span class="keyword">void</span>* args)</span></span></div><div class="line">&#123;</div><div class="line">	co_enable_hook_sys();</div><div class="line">	stEnv_t* env=  (stEnv_t*)args;</div><div class="line">	<span class="keyword">int</span> id = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">	&#123;</div><div class="line">		stTask_t* task = (stTask_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(stTask_t));</div><div class="line">		task-&gt;id = id++;</div><div class="line">		env-&gt;task_queue.push(task);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%s:%d produce task %d\n"</span>, __func__, __LINE__, task-&gt;id);</div><div class="line">		co_cond_signal(env-&gt;cond);  <span class="comment">//唤醒消费者</span></div><div class="line">		poll(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Consumer</span><span class="params">(<span class="keyword">void</span>* args)</span></span></div><div class="line">&#123;</div><div class="line">	co_enable_hook_sys();</div><div class="line">	stEnv_t* env = (stEnv_t*)args;</div><div class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (env-&gt;task_queue.empty())</div><div class="line">		&#123;</div><div class="line">			co_cond_timedwait(env-&gt;cond, <span class="number">-1</span>);  <span class="comment">//等待被唤醒</span></div><div class="line">			<span class="keyword">continue</span>; <span class="comment">//增强检查，被唤醒后，是继续从这句话开始执行的，之后继续判断队列是否为空，增强代码的健壮性。</span></div><div class="line">		&#125;</div><div class="line">		stTask_t* task = env-&gt;task_queue.front();</div><div class="line">		env-&gt;task_queue.pop();</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%s:%d consume task %d\n"</span>, __func__, __LINE__, task-&gt;id);</div><div class="line">		<span class="built_in">free</span>(task);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="汇编部分学习"><a href="#汇编部分学习" class="headerlink" title="汇编部分学习"></a>汇编部分学习</h2><h3 id="C函数调用和栈帧分析"><a href="#C函数调用和栈帧分析" class="headerlink" title="C函数调用和栈帧分析"></a>C函数调用和栈帧分析</h3><p>每个函数对应一个stack frame。</p>
<p>stack frame 的机构为：</p>
<ol>
<li>ebp，储存调用者的stack frame的帧指针。ebp寄存器指向此地址。</li>
<li>保存的寄存器、局部变量以及临时值。</li>
<li>被调函数的 argn, argn-1, …, arg1</li>
<li>返回地址，call语句之后返回的地址。</li>
</ol>
<p>所以，ebp是frame指针，而esp是栈指针，数据的存储与丢弃是esp负责的，而数据的访问则是ebp来负责的。</p>
<p>每个stack frame存储了调用它的ebp，它所调用函数的参数。假设A调用B，B调用C，则在B的帧中保存了A的ebp，C的参数，以及B的局部变量，B的返回地址。</p>
<p>Call语句：把返回地址入栈，把当前寄存器的ebp入栈，接着寄存器的ebp更新为当前esp的值。</p>
<p>Ret语句：弹出栈顶ebp元素到ebp中，接着调到返回地址中继续执行。</p>
<p>若返回值是一个整数或指针，按惯例由eax返回。</p>
<p>寄存器eax, edx, ecx由调用者负责保存。<br>寄存器ebx, esi, edi由被调用者负责保存。</p>
<p>分析调用函数的汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> f1&#123;</div><div class="line">...</div><div class="line"><span class="keyword">int</span> e = f2(a, b)</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在f1调用f2时，负责传递参数、返回地址</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//保存参数</div><div class="line"><span class="keyword">mov</span> b $<span class="built_in">rdi</span></div><div class="line"><span class="keyword">mov</span> a $<span class="built_in">rsi</span>   </div><div class="line"></div><div class="line">//将<span class="built_in">rip</span>的地址入栈，接着更新<span class="built_in">rip</span>的值为f2的地址</div><div class="line"><span class="keyword">call</span> f2</div></pre></td></tr></table></figure>
<p>在f2函数的入口，负责建立自己的栈帧</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span>  $<span class="built_in">rbp</span></div><div class="line"><span class="keyword">mov</span>   $<span class="built_in">rsp</span>  $<span class="built_in">rbp</span></div></pre></td></tr></table></figure>
<p>在f2调用结束时，负责恢复f1的栈帧、执行地址</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">leaveq  //相当于 <span class="keyword">mov</span> <span class="built_in">rbp</span> <span class="built_in">rsp</span><span class="comment">; pop rbp，是入口地方建立栈的反操作</span></div><div class="line"></div><div class="line">retq  //此时栈顶指向返回地址，retq相当于将栈顶的地址出栈赋给<span class="built_in">rip</span></div></pre></td></tr></table></figure>
<h3 id="协程切换coctx-swap-cur-pending"><a href="#协程切换coctx-swap-cur-pending" class="headerlink" title="协程切换coctx_swap(cur, pending)"></a>协程切换coctx_swap(cur, pending)</h3><p><strong>操作</strong>：</p>
<p>存旧：保存原来协程寄存器的值、保存返回地址<br>换新：恢复原来的值到寄存器中、修改栈顶指针esp，恢复返回地址到栈顶，通过ret指令跳到栈顶的地址在开始执行。</p>
<p>函数调用时，参数少于7个时，把参数保存到寄存器中：rdi, rsi, rdx, rcx, r8, r9</p>
<p>刚进入coctx_swap汇编函数中栈结构为：</p>
<p>rbp: 帧地址<br>…<br>rsp：返回地址</p>
<p>第一个参数：cur，保存在rsi中<br>第二个参数：pending，保存在rdi中 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//low | regs[0]: r15 |</span></div><div class="line"><span class="comment">//    | regs[1]: r14 |</span></div><div class="line"><span class="comment">//    | regs[2]: r13 |</span></div><div class="line"><span class="comment">//    | regs[3]: r12 |</span></div><div class="line"><span class="comment">//    | regs[4]: r9  |</span></div><div class="line"><span class="comment">//    | regs[5]: r8  | </span></div><div class="line"><span class="comment">//    | regs[6]: rbp |</span></div><div class="line"><span class="comment">//    | regs[7]: rdi |</span></div><div class="line"><span class="comment">//    | regs[8]: rsi |</span></div><div class="line"><span class="comment">//    | regs[9]: ret |  //ret func addr</span></div><div class="line"><span class="comment">//    | regs[10]: rdx |</span></div><div class="line"><span class="comment">//    | regs[11]: rcx | </span></div><div class="line"><span class="comment">//    | regs[12]: rbx |</span></div><div class="line"><span class="comment">//hig | regs[13]: rsp |</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coctx_t</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">void</span> *regs[<span class="number">14</span>];</div><div class="line">	<span class="keyword">size_t</span> ss_size;</div><div class="line">	<span class="keyword">char</span> *ss_sp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"><span class="built_in">rax</span> -&gt;</div><div class="line">返回地址  </div><div class="line">*/</div><div class="line">leaq <span class="number">8</span>(%rsp),%rax    //刚进入被调函数时，返回地址在栈顶</div><div class="line">leaq <span class="number">112</span>(%rdi),%rsp  //<span class="built_in">rdi</span>指向第一个参数cur，指向regs[<span class="number">13</span>]的尾部</div><div class="line"></div><div class="line">//接下来保存第一个协程的各个寄存器的值</div><div class="line">pushq %rax        //把<span class="built_in">rsp</span>放到cur-&gt;regs[<span class="number">13</span>]中</div><div class="line">pushq %rbx</div><div class="line">pushq %rcx</div><div class="line">pushq %rdx</div><div class="line">pushq -<span class="number">8</span>(%rax) //<span class="keyword">ret</span> func addr</div><div class="line">pushq %rsi</div><div class="line">pushq %rdi</div><div class="line">pushq %rbp</div><div class="line">pushq %r8</div><div class="line">pushq %r9</div><div class="line">pushq %r12</div><div class="line">pushq %r13</div><div class="line">pushq %r14</div><div class="line">pushq %r15</div><div class="line"></div><div class="line">//恢复第二个协程各个寄存器的值</div><div class="line"><span class="keyword">movq</span> %rsi, %rsp   //为什么不是 leaq <span class="number">104</span>(%rsi), %rsp ?? </div><div class="line">popq %r15</div><div class="line">popq %r14</div><div class="line">popq %r13</div><div class="line">popq %r12</div><div class="line">popq %r9</div><div class="line">popq %r8</div><div class="line">popq %rbp</div><div class="line">popq %rdi</div><div class="line">popq %rsi</div><div class="line">popq %rax //<span class="keyword">ret</span> func addr</div><div class="line">popq %rdx</div><div class="line">popq %rcx</div><div class="line">popq %rbx</div><div class="line">popq %rsp</div><div class="line"></div><div class="line">pushq %rax</div><div class="line">xorl %eax, %eax</div><div class="line"><span class="keyword">ret</span>   //<span class="keyword">ret</span> 表示当前栈顶元素为一个执行地址，把改地址出栈并且修改<span class="built_in">eip</span>值</div></pre></td></tr></table></figure>
<h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p>重载阻塞函数，使得函数原来的阻塞挂起变成阻塞切换协程。</p>
<p>以send为例子：send -&gt; poll-&gt; co_poll_inner -&gt; 添加epoll事件 -&gt; 切换协程。<br>在epoll事件后，触发该协程被激活-&gt; 协程切换 -&gt; 继续执行原来代码 -&gt; 执行系统原来的send函数。</p>
<p>系统原来的send函数，通过打开动态库dlsym(RTLD_NEXT, “send”)来获得。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="libco如何实现协程间的平级调用，而普通的C语言为什么不能创建协程"><a href="#libco如何实现协程间的平级调用，而普通的C语言为什么不能创建协程" class="headerlink" title="libco如何实现协程间的平级调用，而普通的C语言为什么不能创建协程"></a>libco如何实现协程间的平级调用，而普通的C语言为什么不能创建协程</h3><p>C语言通过栈来保存自身的数据，传统的函数调用都是一栈接着一栈，从而导致函数间不能同级调用，只能上下调用。而libco把所有协程自己负责栈的创建和维护，在堆中创建栈，并且通过使用汇编语言把sp指向自定义栈。从而使得函数间的调用具有平级效果。</p>
<h3 id="libco协程的优缺点"><a href="#libco协程的优缺点" class="headerlink" title="libco协程的优缺点"></a>libco协程的优缺点</h3><p>协程比线程具有的好处：切换开销小，共享数据不需要加锁。<br>对于独立并发的任务，还是使用多线程才能高效率，而对于加锁或同步问题，可以考虑使用这种协程。</p>
<h3 id="协程保存恢复"><a href="#协程保存恢复" class="headerlink" title="协程保存恢复"></a>协程保存恢复</h3><p>协程的状态包括：</p>
<ol>
<li>寄存器的值（保存到上下文结构coctx）中</li>
<li>当前执行地址（保存到上下文结构coctx）中</li>
<li>普通私有变量，保存到自己的栈帧中</li>
</ol>
<p>所以协程的保存对着三者保存即可，协程的恢复也是对这三者恢复即可。</p>
<p>对于1,2使用汇编语言来访问修改寄存器，对于3,直接使用C语言可以访问修改栈帧了，但要注意对于协程的栈帧，如果是保存在C语言本身的栈中则随着程序的跳转会销毁了，所以需要把它的栈帧改放到堆中来生成，从而可以一直可以访问到。</p>
<h3 id="阻塞超时切换协程"><a href="#阻塞超时切换协程" class="headerlink" title="阻塞超时切换协程"></a>阻塞超时切换协程</h3><p>每个线程维护一个协程栈，一个CoEpoll结构，该结构包含一个epoll fd，以及一个超时事件队列。协程遇到阻塞被切换下一个协程，在超时、epoll事件的回调函数中被重新执行。假如某个协程一直没被阻塞，那么其他协程将没法运行。</p>
<h3 id="同步切换协程"><a href="#同步切换协程" class="headerlink" title="同步切换协程"></a>同步切换协程</h3><p>协程间的同步：协程间共享一个同步结构体（可以是静态数据或堆上的数据），协程通过timewait把自己挂起切换到其他协程中，其他协程则通过signal该结构体重新把挂起的协程重新加到唤醒队列中。</p>
<h3 id="协程栈"><a href="#协程栈" class="headerlink" title="协程栈"></a>协程栈</h3><p>每个线程都会在协程栈的底部创建一个Main协程，main协程没有调用函数。通过co_create创建出来的协程不会直接加到协程栈上，只有当co_resume时，才会把该协程添加到协程栈顶上。</p>
<p>协程栈中的自底往上的结构为： main协程 -&gt; 协程1 -&gt; 协程2(协程1运行过程co_resume(2)) -&gt; 协程3(协程2运行过程中co_resume(3)) …</p>
<p>除main协程外，每个协程的入口函数都是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">CoRoutineFunc</span><span class="params">( stCoRoutine_t *co,<span class="keyword">void</span> * )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>( co-&gt;pfn )</div><div class="line">	&#123;</div><div class="line">		co-&gt;pfn( co-&gt;arg );    <span class="comment">//用户真正自定义的函数，用作co_create中的参数</span></div><div class="line">	&#125;</div><div class="line">	co-&gt;cEnd = <span class="number">1</span>;</div><div class="line"></div><div class="line">	stCoRoutineEnv_t *env = co-&gt;env;</div><div class="line"></div><div class="line">	co_yield_env( env );     <span class="comment">//当前协程退栈，运行下一个栈顶的函数，以上面的例子为例，切换的情况可能为 协程3-&gt;协程2-&gt;协程1-&gt;main协程</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p>libco即可以使用独用栈，每个协程单独分配一个栈，也可以使用共享栈，协程从共享栈中分配获得一个栈，当协程个数超过共享栈中栈数目时，有些协程将会共享同一个栈，假如协程A和B共享一个栈stack，并且出现A协程切换到B协程时，需要先把stack中的数据保存到A的私有空间中，再把B私有空间的数据拷到栈stack中。<br>加入协程个数很多，使用共享栈可以降低空间需求，但是也会增加数据的copy out, copy in的时间开销。</p>
<p>是否使用共享栈的对策：在频繁 co_create 时因为需要创建很多协程，可以考虑使用共享栈。 但是在频繁 co_resume 时因为需要协程间频繁切换， 则可以考虑使用独占栈。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="co-poll-wait-的效率"><a href="#co-poll-wait-的效率" class="headerlink" title="co_poll_wait 的效率"></a>co_poll_wait 的效率</h3><ol>
<li>co_eventloop中在检测事件 co_poll_wait 中是每隔1ms就去检查是否判断超时，检查频繁；</li>
<li>timeout list 有缺陷， timeout list是按ms组成的数组，数组大小是60 * 1000，表示60秒，而co_poll_wait中会把 now - Start 之间的当做超时来处理了，所以该超时最多只能用在60s内的超时，对于大于60s的超时是错误的，里面有一个比较隐秘的地方，加了把大于40的超时都改成40，代码是后来添加的，猜测是他们为了fix而加上的。</li>
</ol>
<p><strong>改进的思考：</strong><br>采用libevent中的思路，修改timeout list，改用最小堆队列来表示，判断时直接检查当前时间是否大于其过期时间，这样可以对大于60s的超时仍然适用；<br>并且按堆中最小的时间设置 co_poll_wait中的timeout参数，避免了固定1ms检查，也减少了频繁调用。</p>
<p><strong>补充：</strong></p>
<p>考虑到微信的并发任务非常大，假如每一毫秒都很可能发生事件。设总事件数为n，激活事件数为k，采用这种的timeout结构，可以在O(k)的时间内来找出所有激活的事件，而采用小根堆的复杂度为O(k*log n)。这样看来，这种timeout结构虽然不能表示大于60s的超时事件，但是在事件频繁的时候，反而可以极大提高效率，所以也不算是缺陷。</p>
<h3 id="协程同步"><a href="#协程同步" class="headerlink" title="协程同步"></a>协程同步</h3><p>用于协程同步的数据结构很简单，不能支持稍微复杂的同步，如生产m才能消费1，或者初值为m的资源。</p>
<p><strong>改进的思考：</strong><br>简单点的可以在链头结构中增加一个变量value表示初始资源，复杂点的同步结构还可以在链头结构中增加func, value。</p>
<h3 id="用户增加协程切换类型"><a href="#用户增加协程切换类型" class="headerlink" title="用户增加协程切换类型"></a>用户增加协程切换类型</h3><p>libco目前支持的协程切换有阻塞切换(如io阻塞)、同步等待切换，用户如何实现更加多类型的切换</p>
<p>用户可以实现两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自动切换的函数 </span></div><div class="line">my_switch()&#123;</div><div class="line">	<span class="keyword">if</span>(...)&#123; <span class="comment">//检查条件</span></div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	use_data *udata;</div><div class="line">	udata-&gt;pfnProcess = my_wakeup</div><div class="line">	co_yield_ct() <span class="comment">//切换当前协程</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//唤醒函数</span></div><div class="line">my_wakeup()&#123;</div><div class="line">	...</div><div class="line"></div><div class="line">	co_resume(co) <span class="comment">//恢复协程</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="协程间唤醒是无状态的，导致协程间的数据传递能力很弱"><a href="#协程间唤醒是无状态的，导致协程间的数据传递能力很弱" class="headerlink" title="协程间唤醒是无状态的，导致协程间的数据传递能力很弱"></a>协程间唤醒是无状态的，导致协程间的数据传递能力很弱</h3><p>唤唤醒协程co时，不提供其他形参，不具备向co传递参数功能。唤醒协程的定义为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_resume</span><span class="params">(stCoRoutine_t *co)</span>    <span class="comment">//</span></span></div></pre></td></tr></table></figure></p>
<p>协程挂起的定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//协程在这里被挂起，当然被唤醒后也是在这语句之后执行，</span></div><div class="line"><span class="comment">//但是被唤醒后是无状态，没有返回值的(返回值是void)，也就没法获得一些额外的信息</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield</span><span class="params">(stCoRoutine_t *co)</span></span></div></pre></td></tr></table></figure>
<p>这种无状态的唤醒、被唤醒能力会有限，使得协程间同步或传递数据能力不强。比如，它不能实现如下的需求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce_action</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	randome produce one food;   <span class="comment">//生产者随机生成一种食品</span></div><div class="line"></div><div class="line">	co_resume(consumer_co,  <span class="string">"cake"</span>);  <span class="comment">//生产者生产了cake，并且唤醒消费者，告知其生成了cake</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer_action</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	food = co_yield()    <span class="comment">//消费者等待生产者生产一种食品</span></div><div class="line"></div><div class="line">	<span class="keyword">switch</span>(food)&#123;  <span class="comment">//根据生产的食品执行不同动作</span></div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>改进的思考：</strong></p>
<p>协程数据结构增加一个成员 void* pArg，用于传递数据，并且修改原来的唤醒、挂起函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_resume</span><span class="params">(stCoRoutine_t *co, <span class="keyword">void</span> *arg, <span class="keyword">size_t</span> arg_len)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(co-&gt;pArg)&#123;</div><div class="line">		<span class="built_in">free</span>(co-&gt;pArg);</div><div class="line">		co-&gt;pArg = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(arg &amp;&amp; arg_len)&#123;</div><div class="line">		co-&gt;pArg = <span class="built_in">malloc</span>(arg_len);</div><div class="line">		<span class="built_in">memcpy</span>(co-&gt;pArg, arg, arg_len);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//原来的co_resume部分</span></div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">co_yield</span><span class="params">(stCoRoutine_t *co)</span></span>&#123;</div><div class="line">	<span class="comment">//原来的co_yield部分</span></div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">return</span> co-&gt;pArg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改写成这样的结构后，就很容易在唤醒其他协程时传递参数，而在被唤醒后，也可以获得返回值了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h3 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h3&gt;&lt;f
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>libevent源码阅读1</title>
    <link href="http://yoursite.com/2017/08/04/libevent_read1/"/>
    <id>http://yoursite.com/2017/08/04/libevent_read1/</id>
    <published>2017-08-04T04:28:26.802Z</published>
    <updated>2017-08-04T04:28:26.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><h3 id="EVCON-DISCONNECTED"><a href="#EVCON-DISCONNECTED" class="headerlink" title="EVCON_DISCONNECTED"></a>EVCON_DISCONNECTED</h3><ul>
<li>创建连接时，evhttp_connection_new</li>
<li>重置 evhttp_connection_reset </li>
<li>重连开始时 evhttp_connection_retry </li>
<li>request之后读回调函数中判断连接已断开</li>
</ul>
<h3 id="EVCON-CONNECTING"><a href="#EVCON-CONNECTING" class="headerlink" title="EVCON_CONNECTING"></a>EVCON_CONNECTING</h3><ul>
<li>连接 evhttp_connection_connect</li>
</ul>
<h3 id="EVCON-IDLE"><a href="#EVCON-IDLE" class="headerlink" title="EVCON_IDLE"></a>EVCON_IDLE</h3><ul>
<li>在连接成功后 evhttp_connectioncb </li>
<li>在处理一个出request成功后</li>
</ul>
<h3 id="EVCON-WRITING"><a href="#EVCON-WRITING" class="headerlink" title="EVCON_WRITING"></a>EVCON_WRITING</h3><ul>
<li>在连接成功后，evhttp_request_dispatch开始处理request</li>
</ul>
<h3 id="EVCON-READING-FIRSTLINE"><a href="#EVCON-READING-FIRSTLINE" class="headerlink" title="EVCON_READING_FIRSTLINE"></a>EVCON_READING_FIRSTLINE</h3><p>读内部状态。</p>
<p>在发送第一个request之后，注册读事件event_read，进入读状态，监听读。</p>
<h3 id="EVCON-READING-HEADERS"><a href="#EVCON-READING-HEADERS" class="headerlink" title="EVCON_READING_HEADERS"></a>EVCON_READING_HEADERS</h3><p>读内部状态。</p>
<h3 id="EVCON-READING-BODY"><a href="#EVCON-READING-BODY" class="headerlink" title="EVCON_READING_BODY"></a>EVCON_READING_BODY</h3><p>读内部状态。</p>
<h3 id="EVCON-READING-TRAILER"><a href="#EVCON-READING-TRAILER" class="headerlink" title="EVCON_READING_TRAILER"></a>EVCON_READING_TRAILER</h3><p>读内部状态。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="evhttp-connection-new-const-char-address-unsigned-int-port"><a href="#evhttp-connection-new-const-char-address-unsigned-int-port" class="headerlink" title="evhttp_connection_new(const char* address, unsigned int port)"></a>evhttp_connection_new(const char* address, unsigned int port)</h3><p>初始化timeout, retry_cnt, input_buffer, output_buffer, request队列， state(EVCON_DISCONNECTED)。</p>
<h3 id="evhttp-connection-connect-struct-evhttp-connection-evcon"><a href="#evhttp-connection-connect-struct-evhttp-connection-evcon" class="headerlink" title="evhttp_connection_connect(struct evhttp_connection *evcon)"></a>evhttp_connection_connect(struct evhttp_connection *evcon)</h3><p>建立连接</p>
<p>先重置自己: evhttp_connection_reset(把连接状态设置为 EVCON_DISCONNECTED)</p>
<p>修改 flag: flag |= EVHTTP_CON_OUTGOING</p>
<p>使用套接字进行连接：bind_socket, socket_connect(socket得到的fd设置为非阻塞的，这里也是非阻塞connect, 并返回成功与否)</p>
<p>添加事件：</p>
<ul>
<li>EV_WRITE的回调函数 </li>
</ul>
<p>evhttp_connectioncb(通过connect的socket，当连接成功时，其事件的状态为可写的)</p>
<ul>
<li>增加超时事件：HTTP_CONNECT_TIMEOUT</li>
</ul>
<p>修改连接状态：EVCON_CONNECTING</p>
<h3 id="evhttp-connectioncb-int-fd-short-what-void-arg"><a href="#evhttp-connectioncb-int-fd-short-what-void-arg" class="headerlink" title="evhttp_connectioncb(int fd, short what, void* arg)"></a>evhttp_connectioncb(int fd, short what, void* arg)</h3><p>连接完成或连接超时，判断：</p>
<ul>
<li>连接已完成 </li>
</ul>
<p>清零retry_cnt，状态变为 EVCON_IDLE，并开始处理request队列(evhttp_request_dispatch)。</p>
<ul>
<li>超时或连接未完成 </li>
</ul>
<p>若没有超出最大重试次数，则2^retry_cnt秒后尝试重新连接(evhttp_connection_retry)，否则重置con，并把它的request队列中的挨个删除并执行回调函数。</p>
<h3 id="evhttp-connection-retry-struct-evhttp-connection-evcon"><a href="#evhttp-connection-retry-struct-evhttp-connection-evcon" class="headerlink" title="evhttp_connection_retry(struct evhttp_connection* evcon)"></a>evhttp_connection_retry(struct evhttp_connection* evcon)</h3><p>状态标为EVCON_DISCONNECTED，并且重来 evhttp_connection_connect</p>
<h3 id="evhttp-make-request-evcon-req-type-uri"><a href="#evhttp-make-request-evcon-req-type-uri" class="headerlink" title="evhttp_make_request(evcon, req, type, uri)"></a>evhttp_make_request(evcon, req, type, uri)</h3><p>请求资源。</p>
<p>将req加入到请求队列中，如果当前未完成连接，先建立连接。若已经建立连接，则直接处理请求(evhttp_request_dispatch)。</p>
<h3 id="evhttp-request-dispatch-struct-evhttp-connection-evcon"><a href="#evhttp-request-dispatch-struct-evhttp-connection-evcon" class="headerlink" title="evhttp_request_dispatch(struct evhttp_connection* evcon)"></a>evhttp_request_dispatch(struct evhttp_connection* evcon)</h3><p>先删除可能的close event: evhttp_connection_stop_detectclose，注意：close_ev 会重置该connection的。</p>
<p>状态变为EVCON_WRITING </p>
<p>生成 header: evhttp_make_header</p>
<p>开始写buffer: evhttp_write_buffer, 写完成后，回调 evhttp_write_connectioncb</p>
<h3 id="evhttp-make-header-struct-evhttp-connection-evcon-struct-evhttp-request-req"><a href="#evhttp-make-header-struct-evhttp-connection-evcon-struct-evhttp-request-req" class="headerlink" title="evhttp_make_header(struct evhttp_connection  evcon, struct evhttp_request  req)"></a>evhttp_make_header(struct evhttp_connection <em> evcon, struct evhttp_request </em> req)</h3><p>如果是request，则evhttp_make_header_request: Method + Uri + HTTP + version + … </p>
<p>否则是response，则evhttp_make_header_response: HTTP + version + status + …</p>
<h3 id="evhttp-write-buffer-evcon-cb-arg"><a href="#evhttp-write-buffer-evcon-cb-arg" class="headerlink" title="evhttp_write_buffer(evcon, cb, arg)"></a>evhttp_write_buffer(<em>evcon, cb, </em>arg)</h3><p>evhttp_write + HTTP_WRITE_TIMEOUT 超时</p>
<p>在 evhttp_write(fd, what, *arg)中</p>
<p>如果是写超时，则会触发 evhttp_connection_fail(evcon, HTTP_WRITE_TIMEOUT)</p>
<p>否则把evcon-&gt;output_buffer中的数据写到fd中，并且调用cb回调。</p>
<h3 id="evhttp-write-connectioncb-evcon-arg"><a href="#evhttp-write-connectioncb-evcon-arg" class="headerlink" title="evhttp_write_connectioncb(evcon, arg)"></a>evhttp_write_connectioncb(<em>evcon, </em>arg)</h3><p>刚刚把request队列中的第一个request给发出去时调用。</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p>把队列中的第一个request类型改为 EVHTTP_RESPONSE.</p>
</li>
<li><p>开始注册读事件 evhttp_start_read(evcon)</p>
</li>
</ol>
<h3 id="evhttp-connection-done-evcon"><a href="#evhttp-connection-done-evcon" class="headerlink" title="evhttp_connection_done(*evcon)"></a>evhttp_connection_done(*evcon)</h3><p>如果是入连接，说明刚刚处理一个request，如果是出连接，说明刚刚处理一个response。</p>
<ul>
<li>如果是出连接 </li>
</ul>
<p>说明刚刚处理一个response，清掉该req， evcon状态变为EVCON_IDLE</p>
<p>如果后面还有request，若当前仍连接，则直接 evhttp_request_dispatch，否则再次连接 evhttp_connection_connect。</p>
<p>如果该连接是persistent的，则不能关闭该连接，并且开启close检测：evhttp_connection_start_detectclose。</p>
<p>执行回调函数。</p>
<ul>
<li>如果是入连接 </li>
</ul>
<p>说明刚处理完一个request, 把状态变为 EVCON_WRITIN，接着执行回调函数。</p>
<h3 id="evhttp-start-read-evcon"><a href="#evhttp-start-read-evcon" class="headerlink" title="evhttp_start_read(evcon)"></a>evhttp_start_read(evcon)</h3><p>在发送request之后，注册读事件。</p>
<p><strong>步骤:</strong></p>
<ol>
<li><p>注册读回调事件 evhttp_read，加入超时 HTTP_READ_TIMEOUT.</p>
</li>
<li><p>状态变为 EVCON_READING_FIRSTLINE</p>
</li>
</ol>
<h3 id="evhttp-handle-chunked-read-struct-evhttp-request-req-struct-evbuffer-buf"><a href="#evhttp-handle-chunked-read-struct-evhttp-request-req-struct-evbuffer-buf" class="headerlink" title="evhttp_handle_chunked_read(struct evhttp_request req, struct evbuffer buf)"></a>evhttp_handle_chunked_read(struct evhttp_request<em> req, struct evbuffer</em> buf)</h3><p>把buf中的数据不断读到req-&gt;input_buffer中去。一个一个chunk的读。 数据格式为 len\r\n + data + len\r\n + … + 0，最后的长度0表示传输完毕。</p>
<p>读的状态有三种：</p>
<ul>
<li>DATA_CORRUPTED </li>
</ul>
<p>数据格式错误。</p>
<ul>
<li>MORE_DATA_EXPECTED </li>
</ul>
<p>若缓冲区的长度小于req-&gt;ntoread留待下次再读，否则只读req-&gt;ntoread，读后把req-&gt;ntoread改成-1表示需要再读进其长度。</p>
<ul>
<li>ALL_DATA_READ </li>
</ul>
<p>遇到最后面的长度0.</p>
<h3 id="evhttp-read-firstline-evcon-req"><a href="#evhttp-read-firstline-evcon-req" class="headerlink" title="evhttp_read_firstline( evcon,  req)"></a>evhttp_read_firstline(<em> evcon, </em> req)</h3><p>读第一行，然后进入读Header状态。</p>
<p>对于request，第一行为 GET HTTP1.1 这样类似的。</p>
<p>对于response，第一行为 HTTP1.1 200 这样类似的。</p>
<p>成功读完后，接着evhttp_read_header。</p>
<h3 id="evhttp-read-header-evcon-req"><a href="#evhttp-read-header-evcon-req" class="headerlink" title="evhttp_read_header( evcon,  req)"></a>evhttp_read_header(<em> evcon, </em> req)</h3><p>读头部。</p>
<p>读完成后，如果req是request或 正常的response，则进入evhttp_read_body， 如果是非正常正常状态的response，则进入evhttp_connection_done。</p>
<h3 id="evhttp-read-body-evcon-req"><a href="#evhttp-read-body-evcon-req" class="headerlink" title="evhttp_read_body(evcon, req)"></a>evhttp_read_body(evcon, req)</h3><p>区分分块传输”Transfer-Encoding: chunked”，则把chunked置为1，并且挨个块进行读取。</p>
<p>如果不是分块(chunked=0)，则要读取body的长度，查看Content-Length，并把长度赋给req-&gt;ntoread。</p>
<p>读body，直到读完成，否则继续添加 evhttp_read + HTTP_READ_TIMEOUT 读事件。</p>
<h3 id="evhttp-read-trailer-evcon-req"><a href="#evhttp-read-trailer-evcon-req" class="headerlink" title="evhttp_read_trailer( evcon,  req)"></a>evhttp_read_trailer(<em> evcon, </em> req)</h3><p>安装读header的格式先读取，读取完成后，进入 evhttp_connection_done中。</p>
<h3 id="evhttp-read-int-fd-short-what-void-arg"><a href="#evhttp-read-int-fd-short-what-void-arg" class="headerlink" title="evhttp_read(int fd, short what, void *arg)"></a>evhttp_read(int fd, short what, void *arg)</h3><p>发送request之后的读回调函数。</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p>如果是超时，则触发 evhttp_connection_fail(evcon, HTTP_READ_TIMEOUT)</p>
</li>
<li><p>把数据从evcon-&gt;input_buffer中读出来。</p>
</li>
<li><p>如果读出来的长度为0，表示连接已经断开，则关闭连接，设置状态为 EVCON_DISCONNECTED, 执行 evhttp_connection_done。</p>
</li>
</ol>
<h3 id="evhttp-send-req-buf"><a href="#evhttp-send-req-buf" class="headerlink" title="evhttp_send(req, buf)"></a>evhttp_send(req, buf)</h3><p>发送请求。</p>
<p><strong>步骤:</strong></p>
<p>把buf中的数据给req，req在后续再传给evcon。</p>
<p>发送完后调用 evhttp_send_done。</p>
<p><strong>相关函数：</strong>  evhttp_send_reply, evhttp_send_reply_start, evhttp_send_reply_end，都是属于服务器端的。</p>
<h3 id="evhttp-send-done-evcon-arg"><a href="#evhttp-send-done-evcon-arg" class="headerlink" title="evhttp_send_done(evcon, arg)"></a>evhttp_send_done(evcon, arg)</h3><p>先删除可能的close event: evhttp_connection_stop_detectclose，注意：close_ev 会重置该connection的。</p>
<h3 id="evhttp-handle-request-evcon-arg"><a href="#evhttp-handle-request-evcon-arg" class="headerlink" title="evhttp_handle_request(evcon, arg)"></a>evhttp_handle_request(evcon, arg)</h3><p>服务端处理request。</p>
<p><strong>步骤：</strong></p>
<p>判断当前连接是否正常，如果连接断开或uri有异常，则返回错误。</p>
<p>处理回调 evhttp_dispatch_callback，注意客户端可能是发多个request的，所以这里callback也是多个。</p>
<p>如果其中有一个uri是成功的，则返回，否则调用通用回调函数，如果其状态不行，则返还page not found。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;状态转换&quot;&gt;&lt;a href=&quot;#状态转换&quot; class=&quot;headerlink&quot; title=&quot;状态转换&quot;&gt;&lt;/a&gt;状态转换&lt;/h2&gt;&lt;h3 id=&quot;EVCON-DISCONNECTED&quot;&gt;&lt;a href=&quot;#EVCON-DISCONNECTED&quot; class=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++知识点学习</title>
    <link href="http://yoursite.com/2017/07/26/c_note/"/>
    <id>http://yoursite.com/2017/07/26/c_note/</id>
    <published>2017-07-26T00:38:47.353Z</published>
    <updated>2017-07-26T00:38:47.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>内联函数需要在.h中定义，一旦内联函数发生修改，所有包含其头文件的文件都需要编译。<br>在类中定义的函数自动成为内敛函数。</p>
<h3 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h3><p>非指针、非引用的const形参和非const形参是等价的，所以const和非const的函数不是重载，会报错。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> A)</span></span></div><div class="line"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(A)</span>      <span class="comment">//error,重定义</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></div><div class="line"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(A&amp;)</span>     <span class="comment">//ok,是重载</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(<span class="keyword">const</span> A*)</span></div><div class="line"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(A* )</span>    <span class="comment">//ok, 是重载</span></div></pre></td></tr></table></figure></p>
<p>typedef, define 只是提供别名，类型本身不变，基于typedef的函数不能重载，会报错。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> A B;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(A)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(B)</span></span>; <span class="comment">//error, 重定义</span></div></pre></td></tr></table></figure></p>
<p>每一个版本的重载函数都应该在同一个作用域中声明。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>mutable 声明的成员变量允许在const的成员函数中被修改。</p>
<h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>可以在类的构造函数声明前加上explicit，防止在调用其构造函数中对参数进行隐式类型转换。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">            A(<span class="built_in">string</span> &amp;);</div><div class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">isEq</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A a;</div><div class="line"></div><div class="line"><span class="comment">//进行隐式转换，生成临时对象A("Hello")进行传参，如果将其构造函数加上explicit，就不能进行类型转换了，这时就会报错。</span></div><div class="line">a.isEq(<span class="string">"Hello"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>struct的成员默认是public的，class的成员默认是private的。</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>包含以下条件的成员，必须在构造函数的初始化列表中进行初始化。</p>
<ol>
<li>没有默认构造函数的成员</li>
<li>const 成员</li>
<li>引用类型成员</li>
</ol>
<p>成员被初始化的次序是根据定义成员的次序。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>如果一个类定义了至少一个构造函数，则编译器再也不会为其生成默认构造函数。<br>默认构造函数中，只会对具有类类型的成员通过运行各自的默认构造函数来进行初始化。内置和复合类型的成员，如指针和数组，只对定义在全局作用域中的对象才进行初始化。<br>类通常都应该定义一个默认构造函数。  </p>
<h3 id="…-显式初始化"><a href="#…-显式初始化" class="headerlink" title="{…} 显式初始化"></a>{…} 显式初始化</h3><p>对于没有定义构造函数，且所有成员都是public的类，可以用{}进行显式初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">            <span class="built_in">string</span> name;</div><div class="line">            <span class="keyword">int</span> age;</div><div class="line">            <span class="built_in">string</span> sex;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A a = &#123; <span class="string">"Jack"</span>, <span class="number">20</span>, <span class="string">"Male"</span> &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>A(const A&amp;)<br>如果定义了复制构造函数，则必须也定义默认构造函数。  </p>
<p>在继承类的复制构造函数和赋值函数中，如果要调用父类的复制构造函数和赋值函数，需要显式调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span></div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Child(<span class="keyword">const</span> Child&amp; rh) : Parent(rh) &#123; ... &#125;</div><div class="line"></div><div class="line">        Child&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Child&amp; rh) </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rh)&#123;</div><div class="line">                Parent::<span class="keyword">operator</span>=(rh);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数和构造函数不一样：</p>
<ol>
<li>析构函数只能有一种方式且是无参数的；</li>
<li>即使定义了用户的析构函数，默认析构函数依然会被调用，在默认析构函数中，会调用各成员各自的析构函数。</li>
<li>在需要释放资源时，析构函数最好定义成虚函数，这样在调用一个基类指针的析构函数时，知道应该调用哪个正确的函数。</li>
</ol>
<p>需要定义析构函数的地方，一般也需要定义拷贝构造函数和赋值函数，这称为三原则。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>构造函数和复制构造函数不能被继承。</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span>  <span class="comment">//友元类</span></div><div class="line"><span class="keyword">friend</span> <span class="keyword">int</span> B::foo(<span class="keyword">void</span>); <span class="comment">//友元成员函数</span></div><div class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//友元普通函数</span></div></pre></td></tr></table></figure>
<h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>重载下标操作符[]时，一般需要重载两个版本：一个非const成员的返回和一个const成员的返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">            <span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> idx) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data[idx]; &#125;</div><div class="line">            <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> idx) &#123; <span class="keyword">return</span> data[idx]; &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>重载自增/自减操作符<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">            <span class="comment">//前缀自增， ++A</span></div><div class="line">            A&amp; <span class="keyword">operator</span>++()</div><div class="line">            &#123;</div><div class="line">                cur++;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//后缀自增，A++</span></div><div class="line">            <span class="comment">//这里增加参数int，是为了和前缀自增进行区别</span></div><div class="line">            A <span class="keyword">operator</span>++(<span class="keyword">int</span>)</div><div class="line">            &#123;</div><div class="line">                A ret = *<span class="keyword">this</span>;</div><div class="line">                ++*<span class="keyword">this</span>;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> ret;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">            <span class="keyword">int</span> cur;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="sizeof是一个运算符，而不是函数"><a href="#sizeof是一个运算符，而不是函数" class="headerlink" title="sizeof是一个运算符，而不是函数"></a>sizeof是一个运算符，而不是函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">c</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">sizeof</span>(struct c); <span class="comment">//4, 静态变量存放在全局数据区，sizeof只计算栈中分配的大小。</span></div></pre></td></tr></table></figure>
<p>sizeof(空类) = 1, sizeof(空类+虚指针) = 4</p>
<h3 id="三目条件运算符编译器生成的代码会优于if…else…"><a href="#三目条件运算符编译器生成的代码会优于if…else…" class="headerlink" title="三目条件运算符编译器生成的代码会优于if…else…"></a>三目条件运算符编译器生成的代码会优于if…else…</h3><h3 id="函数参数的计算顺序是从右往左"><a href="#函数参数的计算顺序是从右往左" class="headerlink" title="函数参数的计算顺序是从右往左"></a>函数参数的计算顺序是从右往左</h3><h3 id="switch中判断的表达式只能为整型或字符型"><a href="#switch中判断的表达式只能为整型或字符型" class="headerlink" title="switch中判断的表达式只能为整型或字符型"></a>switch中判断的表达式只能为整型或字符型</h3><h3 id="数组中地址"><a href="#数组中地址" class="headerlink" title="数组中地址"></a>数组中地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//a, &amp;a[0] 首元素地址；&amp;a 数组首地址</span></div><div class="line"></div><div class="line">a == &amp;a[<span class="number">0</span>]; <span class="comment">//true</span></div><div class="line">a != &amp;a; <span class="comment">//err, a和&amp;a是两个不同类型，不能比较的</span></div></pre></td></tr></table></figure>
<h3 id="三数取中间数"><a href="#三数取中间数" class="headerlink" title="三数取中间数"></a>三数取中间数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">min(max(a,b), max(b,c), max(c,a))</div></pre></td></tr></table></figure>
<h3 id="构造和析构函数执行顺序"><a href="#构造和析构函数执行顺序" class="headerlink" title="构造和析构函数执行顺序"></a>构造和析构函数执行顺序</h3><p>构造函数：基类 -&gt; 成员 -&gt; 派生类<br>析构函数：派生类 -&gt; 成员 -&gt; 基类</p>
<p>注意，即使类定义了自己的析构函数，依然会执行成员和基类的析构函数。</p>
<p>析构函数定义为虚函数： 基类指针指向派生类对象，且delete该指针时。</p>
<h3 id="临时变量可以作参数的定义为-const-A-amp-或-A"><a href="#临时变量可以作参数的定义为-const-A-amp-或-A" class="headerlink" title="临时变量可以作参数的定义为 const A&amp; 或 A"></a>临时变量可以作参数的定义为 const A&amp; 或 A</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(A a)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(A&amp; a)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span></span>;</div><div class="line"></div><div class="line">f1(A()); <span class="comment">//ok</span></div><div class="line">f2(A()); <span class="comment">//err</span></div><div class="line">f3(A()); <span class="comment">//ok</span></div></pre></td></tr></table></figure>
<h3 id="i-和-i-哪个运行快"><a href="#i-和-i-哪个运行快" class="headerlink" title="++i 和 i++ 哪个运行快"></a>++i 和 i++ 哪个运行快</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//++i 的实现</span></div><div class="line"><span class="keyword">int</span> &amp; <span class="keyword">operator</span>++()&#123;</div><div class="line">	*<span class="keyword">this</span> += <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//i++的实现</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</div><div class="line">	<span class="keyword">int</span> tmp = *<span class="keyword">this</span>;</div><div class="line">	++(*<span class="keyword">this</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以++i的效率会更高点，但是实际上编译器会进行优化，两者的效率几乎没差别。</p>
<h3 id="析构函数为什么用虚函数"><a href="#析构函数为什么用虚函数" class="headerlink" title="析构函数为什么用虚函数"></a>析构函数为什么用虚函数</h3><p>基类指针指向派生类对象，delete 该基类指针。</p>
<h3 id="在模板template中，如何声明嵌套从属类型"><a href="#在模板template中，如何声明嵌套从属类型" class="headerlink" title="在模板template中，如何声明嵌套从属类型"></a>在模板template中，如何声明嵌套从属类型</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template&lt;typename C&gt;</div><div class="line">void func(const C&amp; c)&#123;</div><div class="line">	C::iterator it1(c.begin());  //err, 编译遇到C::iterator时，并不会假设它为一个类型，只有加上typename声明它是一个类型时才可以使用；</div><div class="line"></div><div class="line">	typename C::iterator it2(c.begin()); //ok</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器遇到一个未知类型时，并不会假设它就是一个类型，需要显式使用typename告知编译器：这是一个类型。</p>
<h3 id="类的const-static-成员初始化"><a href="#类的const-static-成员初始化" class="headerlink" title="类的const static 成员初始化"></a>类的const static 成员初始化</h3><p>整型(char,int,long,bool)的const static 可以在类内中初始化，其他的类型必须在类外初始化（包括整型数组）。</p>
<h3 id="public-protected-private-继承"><a href="#public-protected-private-继承" class="headerlink" title="public, protected, private 继承"></a>public, protected, private 继承</h3><table>
<thead>
<tr>
<th>继承方式</th>
<th>父public成员</th>
<th>父protected成员</th>
<th>父private成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>子public成员</td>
<td>子protected成员</td>
<td>-</td>
</tr>
<tr>
<td>protected</td>
<td>子protected成员</td>
<td>子protected成员</td>
<td>-</td>
</tr>
<tr>
<td>private</td>
<td>子private成员</td>
<td>子private成员</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="如何避免用户的复制对象行为"><a href="#如何避免用户的复制对象行为" class="headerlink" title="如何避免用户的复制对象行为"></a>如何避免用户的复制对象行为</h3><p>将复制构造函数声明为private</p>
<h3 id="位拷贝（浅拷贝）-vs-值拷贝-深拷贝"><a href="#位拷贝（浅拷贝）-vs-值拷贝-深拷贝" class="headerlink" title="位拷贝（浅拷贝） vs 值拷贝(深拷贝)"></a>位拷贝（浅拷贝） vs 值拷贝(深拷贝)</h3><p>如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p>
<h3 id="赋值函数需要注意什么"><a href="#赋值函数需要注意什么" class="headerlink" title="赋值函数需要注意什么"></a>赋值函数需要注意什么</h3><p>赋值函数一般定义为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> &amp; other)&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;other)&#123;</div><div class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//do sth.</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明，上面中 this==&amp;other 很重要，防止被自复制。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">	<span class="comment">//成员函数格式</span></div><div class="line">	A <span class="keyword">operator</span>+();  <span class="comment">//单目</span></div><div class="line">	A <span class="keyword">operator</span>+(<span class="keyword">const</span> A&amp;); <span class="comment">//双目</span></div><div class="line">	A&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> A&amp;); </div><div class="line"></div><div class="line">	<span class="comment">//友元函数格式</span></div><div class="line">	<span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="keyword">const</span> A&amp;, <span class="keyword">const</span> A&amp;);</div><div class="line"></div><div class="line">	<span class="comment">//特殊运算符重载，且只能以成员函数格式</span></div><div class="line">	A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;); <span class="comment">//复制</span></div><div class="line">	<span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i); <span class="comment">//取下标</span></div><div class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;  <span class="comment">//仿函数</span></div><div class="line">	T <span class="keyword">operator</span>-&gt;();</div><div class="line"></div><div class="line">	<span class="comment">//流操作只能以友元函数重载</span></div><div class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> A&amp;);</div><div class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, A&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一般情况下，单目运算符重载为成员函数；双目运算符重载为友元函数；<br>需要修改成员的运算符一般重载为成员函数；<br>(), [], -&gt;, = 只能重载为成员函数；<br>流操作只能以友元函数重载；</p>
<h3 id="如何实现单例模式"><a href="#如何实现单例模式" class="headerlink" title="如何实现单例模式"></a>如何实现单例模式</h3><p>构造函数、析构函数、复制构造函数、赋值函数都声明为私有，通常的单例模式实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="keyword">protected</span>:</div><div class="line">		Singleton();</div><div class="line"></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">static</span> Singleton* instance;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Singleton::Singleton()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</div><div class="line"></div><div class="line">Singleton* Singleton::getInstance()&#123;</div><div class="line">	<span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</div><div class="line">		instance = <span class="keyword">new</span> Singleton();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="如何实现线程安全的单例模式"><a href="#如何实现线程安全的单例模式" class="headerlink" title="如何实现线程安全的单例模式"></a>如何实现线程安全的单例模式</h3><p>上面中的getInstance不是线程安全的，因为在静态成员初始化时存在竞争关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Singleton* Singleton::getInstance()&#123;</div><div class="line">	<span class="keyword">if</span>(instance != <span class="literal">nullptr</span>)&#123;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	pthread_lock(&amp;lock);</div><div class="line">	<span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</div><div class="line">		instance = <span class="keyword">new</span> Singleton();</div><div class="line">	&#125;</div><div class="line">	pthread_unlock(&amp;lock);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="相等和等级的区别？哪些容器使用相等或等价？"><a href="#相等和等级的区别？哪些容器使用相等或等价？" class="headerlink" title="相等和等级的区别？哪些容器使用相等或等价？"></a>相等和等级的区别？哪些容器使用相等或等价？</h3><p>相等(equality)是以operator==为判断，如果x==y，则x和y成为相等。</p>
<p>等价(equalvalence)是以operator&lt; 为判断，如果 !(x &lt; y) &amp;&amp; !(x &gt; y)，则称为x和y为等价。</p>
<p>顺序容器一般使用“相等”，关联容器一般使用“等价”。</p>
<h3 id="STL中的vector增删元素对迭代器的影响"><a href="#STL中的vector增删元素对迭代器的影响" class="headerlink" title="STL中的vector增删元素对迭代器的影响"></a>STL中的vector增删元素对迭代器的影响</h3><p>对于连续内存容器，如vector,deque，增删元素均会使得当前元素之后的所有迭代器失效。</p>
<p>对于非连续内存容器，如set，map，增删元素只对当前元素的迭代器失效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(it != v.end())&#123;</div><div class="line">	<span class="keyword">if</span>(...)&#123;</div><div class="line">		it = v.erase(it); <span class="comment">//it后面的都无效了</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		it++;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</div><div class="line"><span class="keyword">while</span>(it != m.end())&#123;</div><div class="line">	<span class="keyword">if</span>(...)&#123;</div><div class="line">		m.erase(it++); <span class="comment">//it+1之后仍然有效</span></div><div class="line">		<span class="comment">//也可以写成 it = m.erase(it);</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		it++;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="delete-和-delete"><a href="#delete-和-delete" class="headerlink" title="delete 和 delete[]"></a>delete 和 delete[]</h3><p>delete 对应的是 new， 针对的是单个对象。 delete[] 对应的是new[]，针对的是数组对象。对数组，使用delete[] 时，会对每个对象都调用析构函数，而delete只会对第一个对象调用析构函数。</p>
<p>但是，因为基本类型是没有析构函数的，所以对基本类型数组，delete和delete[] 效果是一样的。</p>
<h3 id="STL中sort的实现是什么"><a href="#STL中sort的实现是什么" class="headerlink" title="STL中sort的实现是什么"></a>STL中sort的实现是什么</h3><p>当数组中数据量比较大时调用quicksort，当分段后的数量小于一定值时，则使用insert sort，当递归的层次过深时，会使用heapsort。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承主要是为了解决多重继承的问题。此时派生类中除了派生类本身的空间外，还要加上父类空间+一个虚类指针。</p>
<h3 id="重载、覆盖和隐藏"><a href="#重载、覆盖和隐藏" class="headerlink" title="重载、覆盖和隐藏"></a>重载、覆盖和隐藏</h3><table>
<thead>
<tr>
<th></th>
<th>作用范围</th>
<th>参数</th>
<th>virtual</th>
</tr>
</thead>
<tbody>
<tr>
<td>重载</td>
<td>相同(同一个类中)</td>
<td>不同</td>
<td>可有可无</td>
</tr>
<tr>
<td>覆盖</td>
<td>不同(父类和子类中)</td>
<td>相同</td>
<td>基类函数带virtual</td>
</tr>
<tr>
<td>隐藏</td>
<td>不同(父类和子类中)</td>
<td>不同，或者相同且基类无virtual</td>
</tr>
</tbody>
</table>
<h3 id="static-cast-和-dynamic-cast"><a href="#static-cast-和-dynamic-cast" class="headerlink" title="static_cast 和 dynamic_cast"></a>static_cast 和 dynamic_cast</h3><p>static_cast&lt; type &gt;(c++形式的)和 c中的(type)转换是具有一样意义的。</p>
<p>dynamic_cast 是将基类的指针或引用指向派生类的指针或引用，当转换失败时，返回一个空指针或抛出异常（引用），其只能应用在包含虚函数的类上。</p>
<h3 id="构造函数可以为虚函数吗？语法和语义上能通过吗？"><a href="#构造函数可以为虚函数吗？语法和语义上能通过吗？" class="headerlink" title="构造函数可以为虚函数吗？语法和语义上能通过吗？"></a>构造函数可以为虚函数吗？语法和语义上能通过吗？</h3><p>不可以。在语法上可以通过，语义上通不过。</p>
<h3 id="实现一个不能在堆分配的类"><a href="#实现一个不能在堆分配的类" class="headerlink" title="实现一个不能在堆分配的类"></a>实现一个不能在堆分配的类</h3><p>是通过new在堆上分配的类的，所以可以重载new操作符，并声明为private。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line">	<span class="keyword">private</span>:</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="实现一个不能被继承的类"><a href="#实现一个不能被继承的类" class="headerlink" title="实现一个不能被继承的类"></a>实现一个不能被继承的类</h3><p>使用c++11中的final</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">final</span>&#123;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="STL中vector-list-map-set-实现"><a href="#STL中vector-list-map-set-实现" class="headerlink" title="STL中vector, list, map, set 实现"></a>STL中vector, list, map, set 实现</h3><ul>
<li><strong>map</strong></li>
</ul>
<p>使用平衡二叉树实现，查找某个数时间为log(n)，插入一个元素时需要重新调整为一棵二叉树，对于未指明位置复杂度为log(n)，指明位置时的平摊复杂度为O(1)。</p>
<ul>
<li><strong>vector</strong></li>
</ul>
<p>在堆中分配内存,元素连续存放,有保留内存,如果减少大小后，内存也不会释放.如果新值&gt;当前大小时才会再分配内存。</p>
<ul>
<li><strong>list</strong></li>
</ul>
<p>list就是双向链表,元素也是在堆中存放,每个元素都是放在一块内存中,它的内存空间可以是不连续的。</p>
<ul>
<li><strong>deque</strong></li>
</ul>
<p>deque就是双向队列，也是在堆中存放，deque中会包含多个堆，堆和堆之间有指针相连，看起来是list和vector的结合。</p>
<p>deque在开始和最后添加元素都一样快,并提供了随机访问方法,像vector一样使用[]访问任意元素,但是随机访问速度比不上vector快,因为它要内部处理堆跳转。</p>
<p>deque也有保留空间。另外,由于deque不要求连续空间,所以可以保存的元素比vector更大。</p>
<ul>
<li><strong>queue 和 stack</strong></li>
</ul>
<p>基于deque</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul>
<li><strong>auto_ptr</strong></li>
</ul>
<p>auto_ptr 是一个类，参数模板是对象。但是C++11已经弃用auto_ptr了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"A"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">auto_ptr</span>&lt;A&gt; ap(<span class="keyword">new</span> A());</div><div class="line"></div><div class="line">ap-&gt;show();</div><div class="line">ap.get();  <span class="comment">//返回原始指针， &amp;A</span></div><div class="line"></div><div class="line"><span class="comment">//判断一个智能指针是否为空</span></div><div class="line"><span class="keyword">if</span>(ap.get()==<span class="literal">NULL</span>) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行智能指针赋值 ap2 = ap1 时, ap2会接管ap1的内存管理权：</p>
<ol>
<li>ap1 变为空指针；</li>
<li>如果ap2不为空，先释放原来的资源，再接管ap1的资源。</li>
</ol>
<ul>
<li><strong>unique_ptr</strong></li>
</ul>
<p>用于取代auto_ptr。</p>
<p>unique_ptr无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作。<br>即不能使用 up2 = up1，但是可以使用 up2 = move(up1)。可以使用 up == NULL 的判断。</p>
<ul>
<li><strong>share_ptr</strong></li>
</ul>
<p>使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。</p>
<p>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<h3 id="用一台4G内存的机器对100G数据进行排序-摘自陈硕博客"><a href="#用一台4G内存的机器对100G数据进行排序-摘自陈硕博客" class="headerlink" title="用一台4G内存的机器对100G数据进行排序[摘自陈硕博客]"></a>用一台4G内存的机器对100G数据进行排序[摘自陈硕博客]</h3><p>使用内存排序(如快排)对100G数据进行分块排序，每块排序后的数据输出到一个文件中，接着使用堆排序对这些已经排好序的文件进行多路归并排序。<br>IO读数据只有两遍。</p>
<h3 id="有-a、-b-两个文件，大小各是-100G-左右，每行长度不超过-1k，这两个文件有少量（几百个）重复的行，要求用一台-4G-内存的机器找出这些重复行-摘自陈硕博客"><a href="#有-a、-b-两个文件，大小各是-100G-左右，每行长度不超过-1k，这两个文件有少量（几百个）重复的行，要求用一台-4G-内存的机器找出这些重复行-摘自陈硕博客" class="headerlink" title="有 a、 b 两个文件，大小各是 100G 左右，每行长度不超过 1k，这两个文件有少量（几百个）重复的行，要求用一台 4G 内存的机器找出这些重复行[摘自陈硕博客]"></a>有 a、 b 两个文件，大小各是 100G 左右，每行长度不超过 1k，这两个文件有少量（几百个）重复的行，要求用一台 4G 内存的机器找出这些重复行[摘自陈硕博客]</h3><p>将a, b 两个文件按行hash到几百个小文件中，再对小文件(a1, b1), (a2, b2) 进行求交集</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h3 id=&quot;内联函数&quot;&gt;&lt;a href=&quot;#内联函数&quot; class=&quot;headerlink&quot; title=&quot;内联函数&quot;&gt;&lt;/a&gt;内联函数&lt;/h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux编程学习</title>
    <link href="http://yoursite.com/2017/07/25/linux_prog/"/>
    <id>http://yoursite.com/2017/07/25/linux_prog/</id>
    <published>2017-07-25T12:06:28.798Z</published>
    <updated>2017-07-25T12:06:28.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li>open</li>
</ul>
<p>open 返回的是一个文件描述符。文件描述符起到的是一个索引的作用，进程通过PCB中的文件描述符表找到该fd所指向的文件指针。</p>
<ul>
<li>fopen</li>
</ul>
<p>流(如fopen) 返回的则是一个FILE结构指针，FILE结构包含有文件描述符fd，FILE结构是对fd直接操作的系统调用的封装，优点是带有IO缓存。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>netstat</li>
</ul>
<p>输出分为:1)Active Internet connections:有源TCP连接。2)Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</p>
<ul>
<li>tcpdump</li>
</ul>
<p>截获通过本机网络接口的数据，用以分析。</p>
<ul>
<li>ipcs(ipc show)</li>
</ul>
<p>ipcs：检查系统上共享内存、消息队列、信号量的分配。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程的状态：</p>
<ul>
<li>可运行：正在运行或者准备运行</li>
<li>等待：等待某个事件或等待资源</li>
<li>暂停：一般是收到某些信号，如SIGSTOP</li>
<li>僵死状态：进程已经结束，但父进程没有执行wait系统调用</li>
</ul>
<p>进程间的通信有：基于Unix的IPC，如信号，管道Pipe；和基于System V/Posix中的信号量，消息队列和共享内存。</p>
<p>子进程的task_struct中的很多地方都是拷贝父进程的task_struct。</p>
<p>除了内核进程，每个进程都有自己的虚拟空间，用mm来记录。</p>
<h3 id="进程间的通信-IPC"><a href="#进程间的通信-IPC" class="headerlink" title="进程间的通信 IPC"></a>进程间的通信 IPC</h3><p>进程间的通信包含同步和互斥两种概念。同步是指进程间相互协调，按顺序处理任务，如生产者-消费者问题。互斥则是指某个资源一次只能被一个进程访问。</p>
<ul>
<li>互斥</li>
</ul>
<p>临界资源：只能被一个进程独占的资源，如打印机，硬盘或内存中被多个进程中的共享数据。<br>临界区：访问临界资源的代码。</p>
<p>实现临界资源的访问：<br>1.硬件方式。因为需要中断才能进行切换，所以可以使用关中断的方式避免进程间的切换，让一个进程执行完临界区代码后再开中断。<br>2.软件方式。使用信号量的PV操作。</p>
<ul>
<li>信号</li>
</ul>
<p>使用信号值signo和信号处理器结构sigaction进行处理的。</p>
<p>关键函数：<br>sigaction, sigaddset, sigdelset</p>
<ul>
<li>信号量</li>
</ul>
<p>使用信号量结构 sem_t 来进行PV操作的。</p>
<ul>
<li>消息队列 </li>
</ul>
<p>进程间通过消息来进行通信。</p>
<p>关键字<br>msgget, msgsnd, msgrcv</p>
<ul>
<li>共享内存</li>
</ul>
<h3 id="进程间通信、线程间通信"><a href="#进程间通信、线程间通信" class="headerlink" title="进程间通信、线程间通信"></a>进程间通信、线程间通信</h3><table>
<thead>
<tr>
<th>类别</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>管道</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>信号</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>信号量</td>
<td>y</td>
<td>y</td>
</tr>
<tr>
<td>共享内存</td>
<td>y</td>
<td>y</td>
</tr>
<tr>
<td>消息队列</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>临界区</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>事件</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>套接字</td>
<td>y</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h2&gt;&lt;h3 id=&quot;文件描述符&quot;&gt;&lt;a href=&quot;#文件描述符&quot; class=&quot;headerlink&quot; title=&quot;文件描述符&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高性能优化</title>
    <link href="http://yoursite.com/2017/07/18/high_perf/"/>
    <id>http://yoursite.com/2017/07/18/high_perf/</id>
    <published>2017-07-18T13:53:41.616Z</published>
    <updated>2017-07-18T13:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fast-UNIX-Servers文章"><a href="#Fast-UNIX-Servers文章" class="headerlink" title="Fast UNIX Servers文章"></a>Fast UNIX Servers文章</h1><p>设计原则：</p>
<ol>
<li><strong>利用带宽</strong><br>避免阻塞IO和不必要的cache，但是使用合适的cache(对处理器cache和其他层级的cache都适用)。<br>利用好多处理器。对齐数据，避免出现cache alias。</li>
<li><strong>不要重复工作</strong><br>避免不必要的拷贝、上下文切换、系统调用和signal。使用双缓存double buffer和ringbuffers，使用像slice那样的调用。<br>双缓冲一般是由于生产者和消费者供需速度不一致所造成的，比如图像显示和CPU两者速度差别比较大，就使用了双缓存。</li>
<li><strong>再三测量</strong><br>使用系统性能测量工具进行性能测量，如Oprofile, dtrace, ktrace。</li>
</ol>
<h1 id="The-C10k-Problem"><a href="#The-C10k-Problem" class="headerlink" title="The C10k Problem"></a>The C10k Problem</h1><p>表示的是Client 10k 问题。</p>
<p>IO策略:</p>
<ol>
<li><p>处理单线程中的多IO调用<br>考虑使用多线程/多进程。<br>使用非阻塞IO(只对网络IO适用，对disk IO不适用);<br>使用异步IO(对网络IO和disk IO都适用)。</p>
</li>
<li><p>如何处理每个client<br>1)每个进程处理一个用户；<br>2)一个OS-level线程处理多个client，每个client又可以被控制：<br>i)一个 user-level thread(如 GNU state thread, 或者 Java中的 green thread)；<br>ii) 一个状态机<br>iii) a continuation<br>3)一个os-level thread处理一个client<br>4)一个os-level thread处理一个active client(如NT completion ports， 线程池等)；</p>
</li>
<li>使用标准的OS service，或者在kernel代码中添加代码。</li>
</ol>
<h2 id="Four-Pool-Performance"><a href="#Four-Pool-Performance" class="headerlink" title="Four Pool Performance"></a>Four Pool Performance</h2><ol>
<li>Data copies</li>
<li>Context switches</li>
<li>Memory allocation </li>
<li>Lock contention </li>
</ol>
<h2 id="Data-copies"><a href="#Data-copies" class="headerlink" title="Data copies"></a>Data copies</h2><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><ul>
<li>os-level thread vs user-level thread </li>
</ul>
<p>os-level thread 指的是操作系统本身提供的，很多语言都支持，如c中通过pthread_create的就是os-level thread，开发人员需要100%负责问题的产生，在没加锁的情况下，即使是native data structure(如dict等)都可能会出问题。</p>
<p>green thread 则是由编程语言本身来管理的，如c中的coroutine和go中的goroutine，这种thread只存在于编程语言中，不存在OS中。green thread编程通常比较简单，但是不能利用多核。通常的方式是开一个os level thread，然后在上面允许很多green thread。</p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li>High-Performance Request-Handling Programs <a href="http://pl.atyp.us/content/tech/servers.html" target="_blank" rel="external">1</a>。</li>
<li>Fast Unix Servers <a href="https://nick-black.com/dankwiki/index.php/Fast_UNIX_Servers" target="_blank" rel="external">2</a>。</li>
<li>The C10k Problem <a href="http://www.kegel.com/c10k.html#related" target="_blank" rel="external">3</a>。</li>
<li>Network Algorithmics: An Interdisciplinary Approach to Designing Fast Networked Devices。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Fast-UNIX-Servers文章&quot;&gt;&lt;a href=&quot;#Fast-UNIX-Servers文章&quot; class=&quot;headerlink&quot; title=&quot;Fast UNIX Servers文章&quot;&gt;&lt;/a&gt;Fast UNIX Servers文章&lt;/h1&gt;&lt;p&gt;设计
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络编程学习</title>
    <link href="http://yoursite.com/2017/07/17/tcp_udp/"/>
    <id>http://yoursite.com/2017/07/17/tcp_udp/</id>
    <published>2017-07-17T00:09:12.483Z</published>
    <updated>2017-07-17T00:09:12.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>进程的每个操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。<br>这与面向字符流的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。<br>UDP不保证数据报能到达目的地。</p>
<p>服务器可以用同一个UDP套接字给多个不同的客户接受数据报，每个客户一个数据报。<br>UDP也可以是全双工的。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP提供的是一种面向连接的、可靠的字节流服务。<br>应用数据被分割成TCP认为最适合发送的的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。</p>
<p>一个端口地址和一个端口称为一个插口socket。插口对socketpair(包含客户端IP和端口，服务端IP和端口)唯一确定一个TCP连接的双方。</p>
<p>TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。<br>TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。</p>
<h3 id="建立连接时"><a href="#建立连接时" class="headerlink" title="建立连接时"></a>建立连接时</h3><p>告知对方：</p>
<ol>
<li>MSS, 即每个TCP分节中愿意接收的最大数据量；</li>
<li>广告窗口规模</li>
<li>时间戳</li>
</ol>
<h2 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h2><p>基本定义：<strong>任意时刻，最多只能有一个未被确认的小块</strong>。<br>目的是尽可能发送大数据块，避免网络中充斥着许多小数据块。小段，是指小于MSS的数据块。<br>Nagle算法的规则，满足以下条件，则允许发送：</p>
<ol>
<li>包长度达到MSS</li>
<li>该包包含有FIN</li>
<li>设置TCP_NODELAY</li>
<li>未设置TCP_CORK，但所有小数据包(长度小于MSS)均被确认；</li>
<li>发生超时(一般为200ms)</li>
</ol>
<p>可以通过设置TCP_NODELAY来禁止Nagle算法。注意此时虽然禁止Nagle算法，但网络的传输依然受到TCP确认延迟机制的影响。</p>
<p>Nagle算法和Cork算法的区别。<br>Nagle着眼于避免网络因小包而拥塞，而Cork着眼于提高网络的利用率。两者在避免发送小包的效果上是一致的。但是Nagle算法在小包都被确认之后会继续发小包，而Cork算法则会继续累积小包。</p>
<h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><p>该协议允许发送方在停止等待确认前可以连续发送多少个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的发送。</p>
<p>+++发送并被确认+++  [ +++发送未被确认+++   +++可被发送+++ ]    +++不可以被发送+++<br>窗口左边沿向右移动，称为窗口合拢，发生在发送或确认数据时；<br>窗口右边沿向右移动，称为窗口张开，接收端读取确认数据并释放TCP缓存；<br>窗口右边沿向左移动，称为窗口收缩。</p>
<p>如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能发送任何数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h1&gt;&lt;p&gt;进程的每个操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。&lt;br&gt;这与面向字符流的协议不同，如TCP，应用程序产生的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>scala基本学习</title>
    <link href="http://yoursite.com/2017/06/28/scala_base/"/>
    <id>http://yoursite.com/2017/06/28/scala_base/</id>
    <published>2017-06-28T06:08:33.211Z</published>
    <updated>2017-06-28T06:08:33.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h1><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>类名第一个字母要大写，方法名第一个字母要小写。</p>
<h3 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//法一</span></div><div class="line"><span class="keyword">package</span> com.reach</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></div><div class="line"></div><div class="line"><span class="comment">//法二</span></div><div class="line"><span class="keyword">package</span> com.reach &#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.<span class="type">Color</span> <span class="comment">//引入Color</span></div><div class="line"><span class="keyword">import</span> java.awt._   <span class="comment">//引入所有成员</span></div><div class="line"><span class="keyword">import</span> java.awt.&#123;<span class="type">Color</span>, <span class="type">Font</span>&#125; <span class="comment">//引入Color, Font</span></div><div class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">HashMap</span> =&gt; <span class="type">JavaHashMap</span>&#125;  <span class="comment">//引入并重命名为JavaHashMap</span></div><div class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">HashMap</span> =&gt; _, _&#125; <span class="comment">//引入util中的所有成员，但是HashMap被隐藏了</span></div></pre></td></tr></table></figure>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Unit: 同void， 用作不返还任何结果的方法的结果类型；<br>Null: null或空引用(null是对象，Null是类型)<br>Nothing: 任何其他类型的子类型<br>Any: 所有其他类的超类<br>AnyRef: 所有引用类的基类</p>
<p>scala没有Java中的原生类型，任何值都是一个对象，方法也是对象。</p>
<h3 id="符号字面量"><a href="#符号字面量" class="headerlink" title="符号字面量"></a>符号字面量</h3><p>‘&lt;标识符&gt;，如’x是scala.Symbol(“x”)的简写。</p>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>“””…”””</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>var声明变量， val声明常量，声明格式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明类型</span></div><div class="line"><span class="keyword">var</span> <span class="type">VariableName</span> : <span class="type">DataType</span> [=  <span class="type">InitialValue</span>]</div><div class="line"></div><div class="line"><span class="comment">//不声明类型，但需要指定初值，会自动推断类型的</span></div><div class="line"><span class="keyword">var</span> <span class="type">VariableName</span> = <span class="type">InitialValue</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> xmax, ymax = <span class="number">100</span>  <span class="comment">// xmax, ymax都声明为100</span></div><div class="line"><span class="keyword">val</span> (myVar1: <span class="type">Int</span>, myVar2: <span class="type">String</span>) = <span class="type">Pair</span>(<span class="number">40</span>, <span class="string">"Foo"</span>)</div><div class="line"><span class="keyword">val</span> (myVar1, myVar2) = <span class="type">Pair</span>(<span class="number">40</span>, <span class="string">"Foo"</span>)</div></pre></td></tr></table></figure></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( i &lt;- <span class="number">1</span> to <span class="number">10</span>)</div><div class="line"><span class="keyword">for</span> (arg &lt;- args)</div></pre></td></tr></table></figure>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类不能访问被嵌套类的私有成员。但是内层类可以访问外层类的私有成员。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>()&#123;println(<span class="string">"f"</span>)&#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerMost</span></span>&#123;</div><div class="line">        f() <span class="comment">// 正确</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    (<span class="keyword">new</span> <span class="type">Inner</span>).f() <span class="comment">//错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 scala 中，对保护（Protected）成员的访问比 java 更严格一些。因为它只允许保护成员在定义了该成员的的类的子类中被访问。而在java中，用protected关键字修饰的成员，除了定义了该成员的类的子类可以访问，同一个包里的其他类也可以进行访问。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p&#123;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>() &#123;println(<span class="string">"f"</span>)&#125;</div><div class="line">    &#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</div><div class="line">	    f()</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;</div><div class="line">		(<span class="keyword">new</span> <span class="type">Super</span>).f() <span class="comment">//错误</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数可以内嵌。</p>
<p>传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部<br>传名调用（call-by-name）：将未计算的参数表达式直接应用到函数内部， 函数参数加上 =&gt;<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(t:<span class="type">Long</span>)  <span class="comment">//传值调用</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(t: =&gt; <span class="type">Long</span>) <span class="comment">//传名调用</span></div></pre></td></tr></table></figure></p>
<p>调用时可以指定参数名，从而可以不按顺序输入参数<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(a:<span class="type">Int</span>, b:<span class="type">Int</span>) = &#123;&#125;</div><div class="line"></div><div class="line">fun(b=<span class="number">10</span>, a=<span class="number">20</span>) <span class="comment">//指定参数名</span></div></pre></td></tr></table></figure></p>
<p>通过*来指明可变参数<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(args: <span class="type">String</span>*) <span class="comment">//args为多个String</span></div></pre></td></tr></table></figure></p>
<p>匿名函数<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inc = (x:<span class="type">Int</span>) =&gt; x + <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>偏应用函数<br>偏应用函数是一种表达式，你不需要提供函数需要的所有参数，只需要提供部分，或不提供所需参数。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date : <span class="type">Date</span>, msg : <span class="type">String</span>) </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myLog</span></span>() = &#123;</div><div class="line">    <span class="keyword">val</span> date = <span class="type">New</span> <span class="type">Date</span></div><div class="line">    <span class="keyword">var</span> logWithDate = log(date, _ : <span class="type">String</span>)</div><div class="line">    logWithDate(<span class="string">"HelloWorld"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数柯里化<br>柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOld</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>)=x+y <span class="comment">//调用 addOld(x, y)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span>)(y:<span class="type">Int</span>) = x + y <span class="comment">//调用 add(x)(y)</span></div><div class="line"></div><div class="line"><span class="comment">//相当于演化成  def add(x:Int) = (y:Int) = x + y</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> add_1 = add(<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> result = add_1(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">//下面的都是等价的</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(arg1,arg2,...,argn) = <span class="type">E</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(arg1)(arg2)...(argn) = <span class="type">E</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(arg1)(arg2)...(argn<span class="number">-1</span>) = &#123; <span class="function"><span class="keyword">def</span> <span class="title">g</span></span>(argn) = <span class="type">E</span>; g &#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(arg1)(arg2)...(argn<span class="number">-1</span>) = argn =&gt; <span class="type">E</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span> </span>= arg1 =&gt; arg2 =&gt; ... =&gt; argn =&gt; <span class="type">E</span></div><div class="line"><span class="keyword">val</span> f = arg1 =&gt; arg2 =&gt; ... =&gt; argn =&gt; <span class="type">E</span></div></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//multiplier访问了函数外的变量factor</span></div><div class="line"><span class="keyword">var</span> factor = <span class="number">3</span>  </div><div class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</div></pre></td></tr></table></figure></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一维数组用Array，多维数组用ofDim。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一维数组</span></div><div class="line"><span class="keyword">var</span> a = <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</div><div class="line"><span class="comment">//多维数组</span></div><div class="line"><span class="keyword">var</span> b = ofDim[<span class="type">Int</span>](<span class="number">3</span>,<span class="number">3</span>)</div></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>表List。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> empty : <span class="type">List</span>[<span class="type">Nothing</span>] = <span class="type">List</span>() <span class="comment">//空表</span></div><div class="line"></div><div class="line"><span class="comment">//可以用::和Nil来构造列表，Nil表示空列表</span></div><div class="line"><span class="keyword">var</span> ls = <span class="number">1</span>::(<span class="number">2</span>::(<span class="number">3</span>::<span class="type">Nil</span>))</div><div class="line"></div><div class="line"><span class="comment">//+: 在列表头添加单个元素, :+ 在列表尾添加元素，这两个操作本身不会改变操作的列表 </span></div><div class="line"><span class="number">2</span> +: ls</div><div class="line">ls :+ <span class="number">3</span></div><div class="line"></div><div class="line"><span class="comment">//head表示第一个元素，tail表示除第一个元素外的剩余元素</span></div><div class="line">ls.head </div><div class="line">ls.tail</div><div class="line"></div><div class="line"><span class="comment">//可以使用::: 或 List:::(ls2) 或 List.concat(...) 来链接多个链表</span></div><div class="line"><span class="keyword">var</span> ls1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</div><div class="line"><span class="keyword">var</span> ls2 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">ls1:::ls2</div><div class="line">ls1.:::(ls2)</div><div class="line"><span class="type">List</span>.concat(ls1, ls2)</div></pre></td></tr></table></figure></p>
<p>元组可以通过t._k来访问第k个元素。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t = (<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> s = t._1 + t._2 + t._3</div></pre></td></tr></table></figure></p>
<p>Option<br>Option[T] 是一个类型为 T 的可选值的容器： 如果值存在， Option[T] 就是一个 Some[T] ，如果不存在， Option[T] 就是对象 None 。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> myMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = <span class="type">Map</span>(<span class="string">"key1"</span> -&gt; <span class="string">"value"</span>)</div><div class="line"><span class="keyword">val</span> value1: <span class="type">Option</span>[<span class="type">String</span>] = myMap.get(<span class="string">"key1"</span>)</div><div class="line"><span class="keyword">val</span> value2: <span class="type">Option</span>[<span class="type">String</span>] = myMap.get(<span class="string">"key2"</span>)</div></pre></td></tr></table></figure></p>
<p>可以使用 getOrElse() 方法来获取元组中存在的元素或者使用其默认的值，类似lua中的or<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a:<span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">None</span> </div><div class="line"><span class="keyword">var</span> b = a.getOrElse(<span class="number">10</span>)  <span class="comment">//10</span></div></pre></td></tr></table></figure></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>用于访问集合中的元素<br>基本操作有next和hasNext</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>重写非抽象方法时要加关键字override</p>
<h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><p>在 Scala 中，是没有 static 这个东西的，但是它也为我们提供了单例模式的实现方法，那就是使用关键字 object。<br>Scala 中使用单例模式时，除了定义的类之外，还要定义一个同名的 object 对象，它和类的区别是，object对象不能带参数。<br>必须在同一个源文件里定义类和它的伴生对象。<br>类和它的伴生对象可以互相访问其私有成员。</p>
<h3 id="Trait-特征"><a href="#Trait-特征" class="headerlink" title="Trait 特征"></a>Trait 特征</h3><p>类似于Java中的接口。<br>调用超类的构造器；<br>特征构造器在超类构造器之后、类构造器之前执行；<br>特质由左到右被构造；<br>每个特征当中，父特质先被构造；<br>如果多个特征共有一个父特质，父特质不会被重复构造<br>所有特征被构造完毕，子类被构造。</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Any</span>): <span class="type">Any</span> = x <span class="keyword">match</span> &#123;</div><div class="line">   <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></div><div class="line">   <span class="keyword">case</span> <span class="string">"two"</span> =&gt; <span class="number">2</span></div><div class="line">   <span class="keyword">case</span> y: <span class="type">Int</span> =&gt; <span class="string">"scala.Int"</span></div><div class="line">   <span class="keyword">case</span> _ =&gt; <span class="string">"many"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>尾递归在函数后面可以直接跳到函数的开头，并且改写函数的参数，从而不需要额外的空间。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//是尾递归</span></div><div class="line"><span class="comment">//gcd(32,24) = gcd(24, 8) = gcd(8, 0) = 8</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a:<span class="type">Int</span>, b:<span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span>(b==<span class="number">0</span>) a </div><div class="line">        <span class="keyword">else</span> gcd(b, a%b)    </div><div class="line"></div><div class="line"><span class="comment">//不是尾递归</span></div><div class="line"><span class="comment">//factor(5) = 5 * factor(4) = 5 * (4 * factor(3)) = 5 * (4 * (3 * factor(2))) = ... = 5*(4*(3*(2*(1*1)))) = 120</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span></span>(a: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> n * factor(n<span class="number">-1</span>)</div><div class="line"></div><div class="line"><span class="comment">//改成尾递归</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span></span>(n: <span class="type">Int</span>):<span class="type">Int</span> = &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Iter</span></span>(x:<span class="type">Int</span>, result:<span class="type">Int</span>):<span class="type">Int</span> = <span class="keyword">if</span>(x==<span class="number">0</span>) result <span class="keyword">else</span> <span class="type">Iter</span>(x<span class="number">-1</span>, result*x)</div><div class="line">    <span class="type">Iter</span>(n, <span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>赋值语句<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> y = <span class="number">0</span></div><div class="line"><span class="keyword">val</span> x = y = <span class="number">10</span>  <span class="comment">//y=10, x = Unit, 说明 y=10 是一个赋值语句，赋值语句类型是Unit</span></div></pre></td></tr></table></figure></p>
<p>while<br>while是scala内置的，但是可以用函数来实现while。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">while</span></span>(p: =&gt; <span class="type">Boolean</span>)(s: =&gt; <span class="type">Unit</span>) = &#123;</div><div class="line">    <span class="keyword">if</span>(p) &#123;</div><div class="line">        s </div><div class="line">        <span class="keyword">while</span>(p)(s)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>def x = e<br>在定义时不会计算表达式e的值，而是在每次使用x的值时，都会计算e值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;零碎知识&quot;&gt;&lt;a href=&quot;#零碎知识&quot; class=&quot;headerlink&quot; title=&quot;零碎知识&quot;&gt;&lt;/a&gt;零碎知识&lt;/h1&gt;&lt;h3 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python小知识</title>
    <link href="http://yoursite.com/2017/06/22/python_tips/"/>
    <id>http://yoursite.com/2017/06/22/python_tips/</id>
    <published>2017-06-22T04:55:46.228Z</published>
    <updated>2017-06-22T04:45:26.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h1><h2 id="构造和析构函数"><a href="#构造和析构函数" class="headerlink" title="构造和析构函数"></a>构造和析构函数</h2><p>__new__是构造函数，在__init__函数之前调用，只使用参数cls，其余参数传给__init__。</p>
<p>__del__是析构函数，并不是语句del x的实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileObject</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filepath)</span>:</span></div><div class="line">        self.file = open(filepath, <span class="string">'r'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line">        self.file.close()</div><div class="line">        <span class="keyword">del</span> self.file</div></pre></td></tr></table></figure>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>__getattr__ 当用户试图访问不存在的属性时，会被调用。<br>__setattr__ 当用户试图设置属性时，不管改属性是否存在，会被调用。<br>__delattr__ 当用户试图删除属性时，不管改属性是否存在，会被调用。</p>
<h2 id="自定义序列"><a href="#自定义序列" class="headerlink" title="自定义序列"></a>自定义序列</h2><ol>
<li>不可变容器<br>需要实现 __len__ 和__getitem__ 方法。</li>
<li>可变容器<br>除了1，还要实现 __setitem__ 和 __delitem__ 方法。</li>
</ol>
<p>为了使容器支持迭代，还需要实现__iter__接口。</p>
<h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>with .. as xx: 做清理时使用，<br>需要定义 __enter__(self) 和 __exit__(self, exception_type, exception_value, traceback)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;魔法方法&quot;&gt;&lt;a href=&quot;#魔法方法&quot; class=&quot;headerlink&quot; title=&quot;魔法方法&quot;&gt;&lt;/a&gt;魔法方法&lt;/h1&gt;&lt;h2 id=&quot;构造和析构函数&quot;&gt;&lt;a href=&quot;#构造和析构函数&quot; class=&quot;headerlink&quot; title=&quot;构造和
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python 类、属性和方法</title>
    <link href="http://yoursite.com/2017/06/22/python_type_object/"/>
    <id>http://yoursite.com/2017/06/22/python_type_object/</id>
    <published>2017-06-22T04:55:46.228Z</published>
    <updated>2017-06-22T04:45:26.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>调用基类的方法时，需要加上基类的类名，并且带上self参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span> </div><div class="line">        <span class="keyword">print</span> <span class="string">'Parent'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span> </div><div class="line">        <span class="keyword">print</span> <span class="string">'Child'</span> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parent_foo</span><span class="params">(self)</span>:</span> </div><div class="line">        Parent.foo(self)</div></pre></td></tr></table></figure></p>
<h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><p>Super是一个类，Super(cls, obj)是根据类和其对象返回一个对象，可以通过Super来调用父类属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></div><div class="line">        Super(Child, self).foo()</div><div class="line">        <span class="comment">#do other things</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<h3 id="新类旧类"><a href="#新类旧类" class="headerlink" title="新类旧类"></a>新类旧类</h3><p>从object继承的是新类，否则为旧类。python 3中所有类都为新类，隐式继承自object。  </p>
<table>
<thead>
<tr>
<th></th>
<th>type(类)</th>
<th>type(实例)</th>
</tr>
</thead>
<tbody>
<tr>
<td>旧类</td>
<td>type ‘classobj’</td>
<td>type ‘instance’</td>
</tr>
<tr>
<td>新类</td>
<td>type ‘type’</td>
<td>class ‘ClassName’</td>
</tr>
</tbody>
</table>
<p>新类本身也是一个对象。</p>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p><strong>__private_attrs</strong> 以双下划线开头的属性为private属性。<br><strong>_protected_attrs</strong> 以单下划线开头的属性为protected属性。</p>
<p>外部访问私有属性时会报错，但是可以通过类名 _ClassName__var 来进行访问。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.__name =  name</div><div class="line"></div><div class="line">c = CC(<span class="string">"dog"</span>)</div><div class="line"><span class="comment"># err</span></div><div class="line"><span class="comment"># print c.__name</span></div><div class="line"></div><div class="line"><span class="comment"># ok </span></div><div class="line"><span class="keyword">print</span> c._CC__name</div></pre></td></tr></table></figure></p>
<h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>元类是用于创建类的类，一般类的元类是type。   </p>
<p>作用：</p>
<ol>
<li>拦截类的创建；</li>
<li>修改类；</li>
<li>返回修改后的类。 </li>
</ol>
<p>在python中，__metaclass__属性用于指明该类创建时使用的元类。 如果没有该属性,则使用type来创建。<br>搜索元类的顺序: 当前类 =&gt; 祖先类 =&gt; 模块 =&gt; type。</p>
<p>可以用type创建类。</p>
<p>概念上是<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#概念上是</span></div><div class="line">MyClass = MetaClass()</div><div class="line">MyObject = MyClass()</div><div class="line"></div><div class="line">type(ClassName, ParentList, AttrDict)</div></pre></td></tr></table></figure></p>
<h3 id="class"><a href="#class" class="headerlink" title="__class__"></a>__class__</h3><p>python中所有东西都是对象，并且也都是从类中生成的。例如整数对象是由类int生成的，字符串对象是由str生成的，而类是由元类生成的。<br>对象的 __class__ 属性表示生成该对象的类。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">age = <span class="number">10</span> </div><div class="line"><span class="keyword">print</span> age.__class__     <span class="comment">#&lt;type 'int'&gt;</span></div><div class="line">name = <span class="string">"bob"</span> </div><div class="line"><span class="keyword">print</span> name.__class__    <span class="comment">#&lt;type 'str'&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> age.__class__.__class__    <span class="comment">#&lt;type 'type'&gt;  生成类的类，元类type</span></div><div class="line"><span class="keyword">print</span> name.__class__.__class__   <span class="comment">#&lt;type 'type'&gt;</span></div></pre></td></tr></table></figure>
<h2 id="types-vs-objects"><a href="#types-vs-objects" class="headerlink" title="types vs objects"></a>types vs objects</h2><p>生成对象的两种方法：</p>
<ol>
<li>通过已有类继承生成新的类(__bases__);</li>
<li>通过已有类实例化对象(__class__)；</li>
</ol>
<h3 id="重要准则"><a href="#重要准则" class="headerlink" title="重要准则"></a>重要准则</h3><ol>
<li><p>Everything is an object<br>所有东西都是object。</p>
</li>
<li><p>Class is type is class<br>class和type的意义是一样的。</p>
</li>
<li><p>Type or non-type test rule<br>判断一个对象是否是一个类，判断它是否 instance of type。 </p>
</li>
</ol>
<p>Object是一切类(自身除外)的父类，type是生成所有类的类。</p>
<h3 id="对象关系图"><a href="#对象关系图" class="headerlink" title="对象关系图"></a>对象关系图</h3><p><a href="/image/types_map.png">关系图</a></p>
<h2 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h2><h3 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a>__dict__</h3><p>用户自定义的属性。 </p>
<p>属性查找顺序(访问obj.attr)：</p>
<ol>
<li>attr是python提供的特殊属性时，返回； </li>
<li>在它的类 __dict__中寻找，如果找到，且是一个data descriptor，则返回 descriptor result；</li>
<li>在该对象的 __dict__中寻找，找到返回；如果该对象也是一个类，则在它的祖先的 __dict__ 中也找。如果找到的是 descriptor， 则返回descriptor result；</li>
<li>在它的类 __dict__中寻找，如果找到，则若是非描述符，则返回；否则应该为non-data descriptor，则返回 descriptor result;</li>
<li>触发异常。</li>
</ol>
<p>总结：python内置属性 =&gt; 类__dict__中的data descriptor =&gt; 对象中的 __dict__ =&gt; 类中的 __dict__ 中的非描述符或non-data descriptor</p>
<p>一些build in类型是没有__dict__的，如list，tuple等，所以用户设置list对象的属性时会报错。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="绑定-Bound-非绑定-UnBound"><a href="#绑定-Bound-非绑定-UnBound" class="headerlink" title="绑定(Bound)/非绑定(UnBound)"></a>绑定(Bound)/非绑定(UnBound)</h3><p>类中定义的方法，类名 + . + 方法名是非绑定， 对象 + . + 是绑定。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">pass</span>  </div><div class="line"></div><div class="line">Foo.foo()       <span class="comment">#未绑定  </span></div><div class="line">Foo().foo()     <span class="comment">#绑定，会报错</span></div></pre></td></tr></table></figure></p>
<p>obj.f是绑定方法，cls.__dict__[“f”]是未绑定方法，可以通过 cls.__dict__[“f”].__get__(obj, cls) 来获得。</p>
<h3 id="Descriptor"><a href="#Descriptor" class="headerlink" title="Descriptor"></a>Descriptor</h3><p>可以把带有__get__方法的object放到类的__dict__中，这些object称为descriptor。 </p>
<p>descriptor包含三个方法：</p>
<ol>
<li>__get__<br>obj.attr或cls.attr来调用</li>
<li>__set__  (可选)<br>obj.attr = .. 时调用</li>
<li>__delete__ (可选)<br>删除属性时调用</li>
</ol>
<p>Descriptor只有绑到类上时才会起作用，绑到一个非class的实例上，不会起任何作用。<br>当d为类C的描述符时，实例 c.d 访问到的都是类C中的对象，要想定义使用自己的d，只能 c.__dict__[“d”]的形式</p>
<p>访问描述符时，类改变描述符时会生效，但实例则不会。</p>
<table>
<thead>
<tr>
<th></th>
<th>__get__</th>
<th>__set__</th>
<th>__delete__</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例</td>
<td>调用</td>
<td>调用</td>
<td>调用</td>
</tr>
<tr>
<td>类</td>
<td>调用</td>
<td>不调用</td>
<td>不调用</td>
</tr>
</tbody>
</table>
<p>只包含__get__的描述符称为non-data descriptor。<br>对于data descriptor，对象无法隐藏类的描述符；类修改d = .. 后，则会把描述符替换成其他对象了，并且不会调用__delete__。<br>对于non-data descriptor，对象可以隐藏类的描述符。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desc</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, cls=None)</span>:</span></div><div class="line">        <span class="keyword">pass</span> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, val)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, obj)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h3 id="类方法-静态方法"><a href="#类方法-静态方法" class="headerlink" title="类方法/静态方法"></a>类方法/静态方法</h3><p>类方法既可以使用类来调用，也可以使用对象来调用。类方法有两个条件</p>
<ol>
<li>使用classmethod描述；</li>
<li>传入的第一个参数是cls；(注意：用self时，只能被实例调用)。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(cls)</span>:</span> <span class="comment">#第一个参数只能是cls</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">Foo.foo() <span class="comment">#ok</span></div><div class="line">Foo().foo() <span class="comment">#ok</span></div></pre></td></tr></table></figure>
<p>静态方法可以被类和对象调用，静态方法用staticmethod修饰器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">    @staticmethod  </span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span> <span class="comment">#不带self和cls</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">Foo.foo() <span class="comment">#ok</span></div><div class="line">Foo().foo() <span class="comment">#ok</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li>python types and objects <a href="http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html" target="_blank" rel="external">1</a>。</li>
<li>python attributes and methods <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html" target="_blank" rel="external">2</a>。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;调用基类的方法时，需要加上基类的类名，并且带上self参数。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;ta
    
    </summary>
    
    
  </entry>
  
</feed>
