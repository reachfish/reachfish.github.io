---

title: 网络编程学习
date: 2017/7/17 09:00:00

---

# UDP
进程的每个操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。
这与面向字符流的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。
UDP不保证数据报能到达目的地。

服务器可以用同一个UDP套接字给多个不同的客户接受数据报，每个客户一个数据报。
UDP也可以是全双工的。

# TCP 
TCP提供的是一种面向连接的、可靠的字节流服务。
应用数据被分割成TCP认为最适合发送的的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。
  
一个端口地址和一个端口称为一个插口socket。插口对socketpair(包含客户端IP和端口，服务端IP和端口)唯一确定一个TCP连接的双方。
  
TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。
TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。

### 建立连接时

告知对方：
1. MSS, 即每个TCP分节中愿意接收的最大数据量；
2. 广告窗口规模
3. 时间戳

当队列已满时，TCP将不理会传入的SYN，也不发回RST作为应答，因为这是一个软错误，而不是一个硬错误。通常队列已满是由于应用程序或操作系统忙造成的，这样可防止应用程序对传入的连接进行服务。

### 关闭连接

一个TCP连接在收到FIN后仍能继续发送数据。

```
	FIN_WAIT_1      --- FIN -->     CLOSE_WAIT
    FIN_WAIT_2      <-- ACK ---     
	TIME_WAIT       <-- FIN ---     LAST_ACT
	                --- ACK -->     CLOSED
```

在TIME_WAIT至少要停留2*MSL的时间，以防止对方没有没有收到ACK，重发一次FIN，从而自己可以再发一次ACK。

2MSL等待期间，这个插口不能使用，只能在2MSL结束后才可以再被使用，同时，任何迟到的报文段将被丢弃。

## Nagle算法
基本定义：**任意时刻，最多只能有一个未被确认的小块**。
目的是尽可能发送大数据块，避免网络中充斥着许多小数据块。小段，是指小于MSS的数据块。
Nagle算法的规则，满足以下条件，则允许发送：
1. 包长度达到MSS
2. 该包包含有FIN
3. 设置TCP_NODELAY
4. 未设置TCP_CORK，但所有小数据包(长度小于MSS)均被确认；
5. 发生超时(一般为200ms)

可以通过设置TCP_NODELAY来禁止Nagle算法。注意此时虽然禁止Nagle算法，但网络的传输依然受到TCP确认延迟机制的影响。

Nagle算法和Cork算法的区别。
Nagle着眼于避免网络因小包而拥塞，而Cork着眼于提高网络的利用率。两者在避免发送小包的效果上是一致的。但是Nagle算法在小包都被确认之后会继续发小包，而Cork算法则会继续累积小包。

## 滑动窗口协议

该协议允许发送方在停止等待确认前可以连续发送多少个分组。
由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的发送。

+++发送并被确认+++  [ +++发送未被确认+++   +++可被发送+++ ]    +++不可以被发送+++ 
窗口左边沿向右移动，称为窗口合拢，发生在发送或确认数据时；
窗口右边沿向右移动，称为窗口张开，这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。
窗口右边沿向左移动，称为窗口收缩。

如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能发送任何数据。

1. 发送方不必发送一个全窗口大小的数据。
2. 接收方在发送一个ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。

__快的发送方和慢的接收方__

发送方发送4个背靠背（back-to-back）的数据报文段去填充接收方的窗口，然后停下来等待一个ACK。
接收方发送ACK（报文段8），但通告其窗口大小为0，这说明接收方已收到所有数据，但这些数据都在接收方的TCP缓冲区，因为应用程序还没有机会读取这些数据。
另一个ACK（称为窗口更新）在17.4ms后发送，表明接收方现在可以接收另外的4096个字节的数据。
虽然这看起来像一个ACK，但由于它并不确认任何新数据，只是用来增加窗口的右边沿，因此被称为窗口更新。

### 慢启动算法(加法增加，乘法减少 AIMD)

发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。


慢启动门限ssthresh

__拥塞避免算法__

cwnd按+1不断增长。

__慢启动算法__

当cwnd小于ssthresh时，*2增长，达到ssthresh时，则进入拥塞避免算法。
当发生拥塞时，把ssthresh变为cwnd的一半，并把cwnd重置为1，然后重新进入慢启动算法。

__快速重传算法__

收到三个相同的ACK时，进行快速重传：
把ssthresh变为cwnd的一半，并把cwnd变为ssthresh。然后重新进入拥塞避免算法。

## tcp可靠性保证

发送方
1. 数据被分割成适合发送的数据块。
2. 超时重发。
3. 拥塞控制。
4. 流量控制(发送方和接送方都有固定大小的缓冲区)。

接收方
1. 发送确认。
2. 数据校验。
3. 乱序重排、丢弃重复。

## 定时器

对每个连接，TCP管理4个不同的定时器。
1. 重传定时器使用于当希望收到另一端的确认。
2. 坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。
3. 保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。
4. 2MSL定时器测量一个连接处于TIME_WA IT状态的时间。

### 术语

* MSS: 最长报文段。默认值是536，常见的是1000+。
* MSL: 每个报文段最大生存时间。

### todo 

TIME_WAIT
